--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         8388608 B, 64 B, direct-mapped
Command:          ./main.x
Data file:        cachegrind.out.7779
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                      I1mr                 ILmr           Dr                     D1mr             DLmr           Dw                     D1mw           DLmw           
--------------------------------------------------------------------------------
23,552,360,248 (100.0%) 210,003,176 (100.0%) 2,500 (100.0%) 5,799,554,211 (100.0%) 224,902 (100.0%) 7,863 (100.0%) 3,517,810,732 (100.0%) 2,870 (100.0%) 1,873 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                     I1mr                ILmr         Dr                   D1mr            DLmr           Dw                   D1mw           DLmw          file:function
--------------------------------------------------------------------------------
4,056,400,926 (17.22%) 48,000,063 (22.86%)  64 ( 2.56%) 836,940,366 (14.43%)      4 ( 0.00%)     4 ( 0.05%) 541,329,989 (15.39%)     7 ( 0.24%)   7 ( 0.37%)  ./stdio-common/./stdio-common/printf_fp.c:__printf_fp_l
1,699,059,937 ( 7.21%) 24,000,360 (11.43%) 309 (12.36%) 463,196,338 ( 7.99%)  2,349 ( 1.04%)    10 ( 0.13%) 232,889,431 ( 6.62%)    21 ( 0.73%)  13 ( 0.69%)  ???:???
1,644,000,000 ( 6.98%) 12,000,035 ( 5.71%)  31 ( 1.24%) 378,000,000 ( 6.52%)      7 ( 0.00%)     5 ( 0.06%) 276,000,000 ( 7.85%)     3 ( 0.10%)   3 ( 0.16%)  ./stdio-common/./stdio-common/vfprintf-internal.c:__vfprintf_internal
1,050,000,000 ( 4.46%)          3 ( 0.00%)   3 ( 0.12%) 336,000,000 ( 5.79%)      0              0          168,000,000 ( 4.78%)     0            0           ./stdio-common/./stdio-common/printf_fp.c:hack_digit
1,007,999,999 ( 4.28%)          3 ( 0.00%)   3 ( 0.12%) 306,000,000 ( 5.28%)      4 ( 0.00%)     0          144,000,001 ( 4.09%)     0            0           ./libio/./libio/iofwrite.c:fwrite
  882,000,000 ( 3.74%) 12,000,001 ( 5.71%)   3 ( 0.12%) 126,000,000 ( 2.17%)      0              0           84,000,000 ( 2.39%)     0            0           ./stdlib/../sysdeps/x86_64/mul_1.S:__mpn_mul_1
  881,999,640 ( 3.74%)         15 ( 0.00%)  14 ( 0.56%) 191,999,820 ( 3.31%)      0              0          173,999,940 ( 4.95%)     0            0           ???:std::ostreambuf_iterator<char, std::char_traits<char> > std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::_M_insert_float<double>(std::ostreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, char, char, double) const
  828,000,013 ( 3.52%)          4 ( 0.00%)   4 ( 0.16%) 180,000,004 ( 3.10%)      0              0          144,000,000 ( 4.09%)     0            0           ./libio/./libio/fileops.c:_IO_file_xsputn@@GLIBC_2.2.5
  690,000,329 ( 2.93%)          3 ( 0.00%)   3 ( 0.12%) 240,000,114 ( 4.14%)      2 ( 0.00%)     0          150,000,071 ( 4.26%)     0            0           ???:std::ostream::sentry::sentry(std::ostream&)
  558,000,003 ( 2.37%) 12,000,012 ( 5.71%)   7 ( 0.28%) 114,000,000 ( 1.97%)      2 ( 0.00%)     0          108,000,000 ( 3.07%)     0            0           ???:std::ostreambuf_iterator<char, std::char_traits<char> > std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::_M_insert_int<long>(std::ostreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, char, long) const
  414,003,950 ( 1.76%)          2 ( 0.00%)   2 ( 0.08%)  77,999,748 ( 1.34%)      0              0           47,999,809 ( 1.36%)     0            0           ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms
  384,006,418 ( 1.63%)         78 ( 0.00%)  14 ( 0.56%) 120,001,844 ( 2.07%)     10 ( 0.00%)     0           66,000,821 ( 1.88%)     0            0           ./malloc/./malloc/malloc.c:_int_free
  378,430,694 ( 1.61%)  6,000,006 ( 2.86%)   6 ( 0.24%)  84,121,111 ( 1.45%)      0              0           84,000,000 ( 2.39%)     0            0           /home/juanb3ltran/Documentos/Universidad/Alto_rendimiento/Cream_drop/Main/utils.cpp:Particle::moveRandom(double, double, double, double, double, std::mersenne_twister_engine<unsigned long, 32ul, 624ul, 397ul, 31ul, 2567483615ul, 11ul, 4294967295ul, 7ul, 2636928640ul, 15ul, 4022730752ul, 18ul, 1812433253ul>&)
  373,858,698 ( 1.59%)          3 ( 0.00%)   2 ( 0.08%)  84,419,706 ( 1.46%)      0              0           72,359,748 ( 2.06%)     0            0           /usr/include/c++/11/bits/uniform_int_dist.h:int std::uniform_int_distribution<int>::operator()<std::mersenne_twister_engine<unsigned long, 32ul, 624ul, 397ul, 31ul, 2567483615ul, 11ul, 4294967295ul, 7ul, 2636928640ul, 15ul, 4022730752ul, 18ul, 1812433253ul> >(std::mersenne_twister_engine<unsigned long, 32ul, 624ul, 397ul, 31ul, 2567483615ul, 11ul, 4294967295ul, 7ul, 2636928640ul, 15ul, 4022730752ul, 18ul, 1812433253ul>&, std::uniform_int_distribution<int>::param_type const&) [clone .isra.0]
  342,000,018 ( 1.45%)          9 ( 0.00%)   7 ( 0.28%) 138,000,006 ( 2.38%)      3 ( 0.00%)     0           54,000,003 ( 1.54%)     0            0           ???:std::ostream& std::ostream::_M_insert<long>(long)
  342,000,000 ( 1.45%) 12,000,003 ( 5.71%)   5 ( 0.20%)  78,000,000 ( 1.34%)      0              0           90,000,000 ( 2.56%)     0            0           ./libio/./libio/vsnprintf.c:__vsnprintf_internal
  342,000,000 ( 1.45%)          5 ( 0.00%)   5 ( 0.20%) 138,000,000 ( 2.38%)      1 ( 0.00%)     0           54,000,000 ( 1.54%)     0            0           ???:std::ostream& std::ostream::_M_insert<double>(double)
  336,000,005 ( 1.43%)  6,000,011 ( 2.86%)   5 ( 0.20%) 102,000,001 ( 1.76%)      0              0           66,000,000 ( 1.88%)     0            0           ./libio/./libio/fileops.c:_IO_do_write@@GLIBC_2.2.5
  336,000,000 ( 1.43%)  6,000,011 ( 2.86%)   5 ( 0.20%) 144,000,000 ( 2.48%)      0              0           72,000,000 ( 2.05%)     0            0           ???:std::basic_ostream<char, std::char_traits<char> >& std::__ostream_insert<char, std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&, char const*, long)
  318,955,148 ( 1.35%) 12,000,008 ( 5.71%)   8 ( 0.32%)  67,210,925 ( 1.16%)      0              0           48,347,382 ( 1.37%)     0            0           /home/juanb3ltran/Documentos/Universidad/Alto_rendimiento/Cream_drop/Main/utils.cpp:delta_entropy(std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<int const, int> > >&, double, double, double, double, double, double, int, double, double, int)
  306,000,000 ( 1.30%)          2 ( 0.00%)   2 ( 0.08%)  90,000,000 ( 1.55%)      0              0           18,000,000 ( 0.51%)     0            0           ./libio/./libio/libioP.h:fwrite
  288,000,000 ( 1.22%) 12,000,009 ( 5.71%)   4 ( 0.16%)  42,000,000 ( 0.72%)      0              0           66,000,000 ( 1.88%)     0            0           ./libio/./libio/strops.c:_IO_str_init_static_internal
  280,242,238 ( 1.19%)          6 ( 0.00%)   4 ( 0.16%)  36,236,636 ( 0.62%) 52,836 (23.49%)     0           18,089,375 ( 0.51%)     0            0           /usr/include/c++/11/bits/random.tcc:std::mersenne_twister_engine<unsigned long, 32ul, 624ul, 397ul, 31ul, 2567483615ul, 11ul, 4294967295ul, 7ul, 2636928640ul, 15ul, 4022730752ul, 18ul, 1812433253ul>::_M_gen_rand()
  264,000,044 ( 1.12%)          4 ( 0.00%)   2 ( 0.08%) 108,000,018 ( 1.86%)      7 ( 0.00%)     0           48,000,008 ( 1.36%)     0            0           ./locale/./locale/uselocale.c:uselocale
  258,003,594 ( 1.10%)         16 ( 0.00%)   7 ( 0.28%)  66,000,898 ( 1.14%)      9 ( 0.00%)     2 ( 0.03%)  36,000,329 ( 1.02%)     0            0           ./malloc/./malloc/malloc.c:malloc
  253,310,871 ( 1.08%)          6 ( 0.00%)   4 ( 0.16%)  24,137,167 ( 0.42%) 24,804 (11.03%)     0           12,077,209 ( 0.34%)     0            0           /usr/include/c++/11/bits/random.tcc:int std::uniform_int_distribution<int>::operator()<std::mersenne_twister_engine<unsigned long, 32ul, 624ul, 397ul, 31ul, 2567483615ul, 11ul, 4294967295ul, 7ul, 2636928640ul, 15ul, 4022730752ul, 18ul, 1812433253ul> >(std::mersenne_twister_engine<unsigned long, 32ul, 624ul, 397ul, 31ul, 2567483615ul, 11ul, 4294967295ul, 7ul, 2636928640ul, 15ul, 4022730752ul, 18ul, 1812433253ul>&, std::uniform_int_distribution<int>::param_type const&) [clone .isra.0]
  252,000,000 ( 1.07%)          4 ( 0.00%)   4 ( 0.16%) 114,000,000 ( 1.97%)      0              0           36,000,000 ( 1.02%)     0            0           ???:std::ostream::put(char)
  246,007,680 ( 1.04%)          9 ( 0.00%)   9 ( 0.36%)  72,002,017 ( 1.24%)      4 ( 0.00%)     1 ( 0.01%)  66,002,021 ( 1.88%)     1 ( 0.03%)   0           /home/juanb3ltran/Documentos/Universidad/Alto_rendimiento/Cream_drop/Main/main.cpp:main
  228,000,542 ( 0.97%)          7 ( 0.00%)   4 ( 0.16%) 114,000,269 ( 1.97%)      8 ( 0.00%)     0           30,000,072 ( 0.85%)     0            0           ???:std::ostream::flush()
  228,000,000 ( 0.97%)          5 ( 0.00%)   2 ( 0.08%)  24,000,000 ( 0.41%)      0              0                    0              0            0           ./string/../sysdeps/x86_64/multiarch/strchr-avx2.S:__strchrnul_avx2
  222,000,000 ( 0.94%)          3 ( 0.00%)   3 ( 0.12%)  48,000,000 ( 0.83%)      0              0           30,000,000 ( 0.85%)     0            0           ./libio/./libio/fileops.c:_IO_file_write@@GLIBC_2.2.5
  186,000,000 ( 0.79%)          3 ( 0.00%)   3 ( 0.12%)  18,000,000 ( 0.31%)      1 ( 0.00%)     1 ( 0.01%)  24,000,000 ( 0.68%)     0            0           ???:std::__num_base::_S_format_float(std::ios_base const&, char*, char)
  180,000,600 ( 0.76%)          5 ( 0.00%)   3 ( 0.12%)  78,000,260 ( 1.34%)      7 ( 0.00%)     2 ( 0.03%)  30,000,100 ( 0.85%)     0            0           ./libio/./libio/iofflush.c:fflush
  156,000,048 ( 0.66%)          3 ( 0.00%)   2 ( 0.08%)  30,000,010 ( 0.52%)      0              0           24,000,008 ( 0.68%)     0            0           ./libio/./libio/genops.c:_IO_setb
  150,000,396 ( 0.64%) 12,000,006 ( 5.71%)   3 ( 0.12%)  48,000,154 ( 0.83%)      1 ( 0.00%)     1 ( 0.01%)  24,000,066 ( 0.68%)     0            0           ./libio/./libio/fileops.c:_IO_file_sync@@GLIBC_2.2.5
  138,000,000 ( 0.59%)          3 ( 0.00%)   3 ( 0.12%)  30,000,000 ( 0.52%)      0              0           48,000,000 ( 1.36%)     0            0           ./libio/./libio/genops.c:_IO_no_init
  138,000,000 ( 0.59%)          2 ( 0.00%)   2 ( 0.08%)  18,000,000 ( 0.31%)      1 ( 0.00%)     1 ( 0.01%)  60,000,000 ( 1.71%)     0            0           ./libio/./libio/genops.c:_IO_old_init
  132,001,738 ( 0.56%) 12,000,003 ( 5.71%)   3 ( 0.12%)  48,000,632 ( 0.83%)      7 ( 0.00%)     0           24,000,316 ( 0.68%)     0            0           ./malloc/./malloc/malloc.c:free
  132,000,000 ( 0.56%)          2 ( 0.00%)   2 ( 0.08%)   6,000,000 ( 0.10%)      0              0           24,000,000 ( 0.68%)     1 ( 0.03%)   1 ( 0.05%)  ./stdlib/../sysdeps/ieee754/dbl-64/dbl2mpn.c:__mpn_extract_double
  126,046,768 ( 0.54%)          5 ( 0.00%)   4 ( 0.16%)  12,011,692 ( 0.21%) 14,973 ( 6.66%)     0            6,011,692 ( 0.17%)     0            0           /usr/include/c++/11/bits/random.tcc:getRandomInt(int, std::mersenne_twister_engine<unsigned long, 32ul, 624ul, 397ul, 31ul, 2567483615ul, 11ul, 4294967295ul, 7ul, 2636928640ul, 15ul, 4022730752ul, 18ul, 1812433253ul>&, bool)
  126,000,000 ( 0.53%)          2 ( 0.00%)   2 ( 0.08%)  42,000,000 ( 0.72%)      0              0           30,000,000 ( 0.85%)     0            0           ./libio/./libio/putc.c:putc
  120,000,000 ( 0.51%)          2 ( 0.00%)   2 ( 0.08%)  12,000,000 ( 0.21%)      0              0                    0              0            0           ./string/../sysdeps/x86_64/multiarch/memchr-avx2.S:__memchr_avx2
  108,000,978 ( 0.46%)          2 ( 0.00%)   2 ( 0.08%)  36,000,326 ( 0.62%)     11 ( 0.00%)     4 ( 0.05%)          96 ( 0.00%)     0            0           ???:std::locale::id::_M_id() const
  108,000,360 ( 0.46%)          2 ( 0.00%)   1 ( 0.04%)  30,000,100 ( 0.52%)      0              0           12,000,040 ( 0.34%)     0            0           ./libio/./libio/libioP.h:fflush
  108,000,000 ( 0.46%)          2 ( 0.00%)   2 ( 0.08%)  18,000,000 ( 0.31%)      1 ( 0.00%)     0                    0              0            0           ???:__gnu_cxx::stdio_sync_filebuf<char, std::char_traits<char> >::xsputn(char const*, long)
   96,000,016 ( 0.41%)          3 ( 0.00%)   2 ( 0.08%)  12,000,002 ( 0.21%)      0              0            6,000,001 ( 0.17%)     0            0           ./stdlib/../sysdeps/x86_64/lshift.S:__mpn_lshift
   96,000,001 ( 0.41%)          1 ( 0.00%)   0           30,000,000 ( 0.52%)    766 ( 0.34%)     0           24,000,000 ( 0.68%)     0            0           /usr/include/c++/11/ostream:main
   96,000,000 ( 0.41%)          2 ( 0.00%)   2 ( 0.08%)  36,000,000 ( 0.62%)      0              0           30,000,000 ( 0.85%)     0            0           /home/juanb3ltran/Documentos/Universidad/Alto_rendimiento/Cream_drop/Main/utils.cpp:getRandomInt(int, std::mersenne_twister_engine<unsigned long, 32ul, 624ul, 397ul, 31ul, 2567483615ul, 11ul, 4294967295ul, 7ul, 2636928640ul, 15ul, 4022730752ul, 18ul, 1812433253ul>&, bool)
   95,999,756 ( 0.41%)          1 ( 0.00%)   1 ( 0.04%)           0               0              0                    0              0            0           ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__mempcpy_avx_unaligned_erms
   84,000,966 ( 0.36%)          7 ( 0.00%)   2 ( 0.08%)  12,000,138 ( 0.21%)      6 ( 0.00%)     5 ( 0.06%)           0              0            0           ./string/../sysdeps/x86_64/multiarch/strlen-avx2.S:__strlen_avx2
   84,000,000 ( 0.36%)          0            0           12,000,000 ( 0.21%)    767 ( 0.34%)     0            6,000,000 ( 0.17%)     0            0           ./stdio-common/../libio/libioP.h:__vfprintf_internal
   72,000,948 ( 0.31%)  6,000,001 ( 2.86%)   2 ( 0.08%)  12,000,158 ( 0.21%)      0              0           12,000,158 ( 0.34%)     0            0           ???:operator new(unsigned long)
   66,000,044 ( 0.28%)          4 ( 0.00%)   2 ( 0.08%)  36,000,024 ( 0.62%)      2 ( 0.00%)     0           12,000,008 ( 0.34%)     0            0           ???:std::ctype<char> const& std::use_facet<std::ctype<char> >(std::locale const&)
   66,000,009 ( 0.28%)          3 ( 0.00%)   3 ( 0.12%)  30,000,002 ( 0.52%)      0              0                    2 ( 0.00%)     0            0           /usr/include/c++/11/bits/stl_vector.h:main
   66,000,000 ( 0.28%) 12,000,000 ( 5.71%)   2 ( 0.08%)  12,000,000 ( 0.21%)      1 ( 0.00%)     0                    0              0            0           ./nptl/./nptl/alloca_cutoff.c:__libc_alloca_cutoff
   66,000,000 ( 0.28%)          1 ( 0.00%)   1 ( 0.04%)  18,000,000 ( 0.31%)      2 ( 0.00%)     0                    0              0            0           ???:std::ostream::operator<<(int)
   60,000,058 ( 0.25%)          8 ( 0.00%)   8 ( 0.32%)  12,000,010 ( 0.21%)      0              0                    8 ( 0.00%)     0            0           ./libio/./libio/genops.c:_IO_default_xsputn
   60,000,000 ( 0.25%)          0            0                    0               0              0                    0              0            0           /usr/include/c++/11/bits/uniform_int_dist.h:getRandomInt(int, std::mersenne_twister_engine<unsigned long, 32ul, 624ul, 397ul, 31ul, 2567483615ul, 11ul, 4294967295ul, 7ul, 2636928640ul, 15ul, 4022730752ul, 18ul, 1812433253ul>&, bool)
   54,269,811 ( 0.23%)          0            0                    0               0              0           12,059,958 ( 0.34%)     0            0           /usr/include/c++/11/bits/uniform_int_dist.h:Particle::moveRandom(double, double, double, double, double, std::mersenne_twister_engine<unsigned long, 32ul, 624ul, 397ul, 31ul, 2567483615ul, 11ul, 4294967295ul, 7ul, 2636928640ul, 15ul, 4022730752ul, 18ul, 1812433253ul>&)
   54,000,135 ( 0.23%)          4 ( 0.00%)   1 ( 0.04%)  12,000,030 ( 0.21%)      1 ( 0.00%)     0            6,000,015 ( 0.17%)     0            0           ???:std::locale::facet::_S_get_c_locale()
   54,000,000 ( 0.23%)          2 ( 0.00%)   2 ( 0.08%)  12,000,000 ( 0.21%)      0              0                    0              0            0           ./io/../sysdeps/unix/sysv/linux/write.c:write
   54,000,000 ( 0.23%)          0            0           12,000,000 ( 0.21%)      0              0            6,000,000 ( 0.17%)     0            0           /usr/include/c++/11/ext/new_allocator.h:Particle::moveRandom(double, double, double, double, double, std::mersenne_twister_engine<unsigned long, 32ul, 624ul, 397ul, 31ul, 2567483615ul, 11ul, 4294967295ul, 7ul, 2636928640ul, 15ul, 4022730752ul, 18ul, 1812433253ul>&)
   54,000,000 ( 0.23%)          0            0            6,000,000 ( 0.10%)      0              0           18,000,000 ( 0.51%)     0            0           ./stdio-common/./stdio-common/printf-parse.h:__vfprintf_internal
   53,016,288 ( 0.23%)          6 ( 0.00%)   5 ( 0.20%)  12,677,808 ( 0.22%) 10,774 ( 4.79%)    36 ( 0.46%)           0              0            0           ./math/../sysdeps/ieee754/dbl-64/e_log.c:__ieee754_log_fma
   50,299,980 ( 0.21%)          5 ( 0.00%)   3 ( 0.12%)  17,343,857 ( 0.30%)      0              0           10,405,780 ( 0.30%)     0            0           /usr/include/c++/11/bits/hashtable_policy.h:std::__detail::_Map_base<int, std::pair<int const, int>, std::allocator<std::pair<int const, int> >, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>, true>::operator[](int&&)
   48,000,000 ( 0.20%)  6,000,000 ( 2.86%)   1 ( 0.04%)           0               0              0                    0              0            0           ./libio/./libio/libioP.h:_IO_do_write@@GLIBC_2.2.5
   48,000,000 ( 0.20%)          8 ( 0.00%)   2 ( 0.08%)   6,000,000 ( 0.10%)      0              0            6,000,000 ( 0.17%)     0            0           ./stdio-common/../sysdeps/generic/get-rounding-mode.h:__printf_fp_l
   42,000,000 ( 0.18%)          1 ( 0.00%)   1 ( 0.04%)  12,000,000 ( 0.21%)      0              0                    0              0            0           ./stdio-common/./stdio-common/printf_fp.c:__printf_fp
   42,000,000 ( 0.18%)          1 ( 0.00%)   1 ( 0.04%)   6,000,000 ( 0.10%)      0              0                    0              0            0           ???:__gnu_cxx::stdio_sync_filebuf<char, std::char_traits<char> >::overflow(int)
   42,000,000 ( 0.18%)          0            0            6,000,000 ( 0.10%)      0              0            6,000,000 ( 0.17%)     0            0           ./stdio-common/../sysdeps/pthread/allocalim.h:__printf_fp_l
   36,001,200 ( 0.15%)          1 ( 0.00%)   1 ( 0.04%)  24,000,800 ( 0.41%)      0              0                    0              0            0           /home/juanb3ltran/Documentos/Universidad/Alto_rendimiento/Cream_drop/Main/utils.cpp:Particle::getY() const
   36,001,200 ( 0.15%)          1 ( 0.00%)   0           24,000,800 ( 0.41%) 77,339 (34.39%)     0                    0              0            0           /home/juanb3ltran/Documentos/Universidad/Alto_rendimiento/Cream_drop/Main/utils.cpp:Particle::getX() const
   36,000,089 ( 0.15%)          2 ( 0.00%)   1 ( 0.04%)  12,000,029 ( 0.21%)      3 ( 0.00%)     0                    0              0            0           ./nptl/./nptl/pthread_once.c:pthread_once@@GLIBC_2.34
   24,000,000 ( 0.10%)          1 ( 0.00%)   1 ( 0.04%)           0               0              0                    0              0            0           ???:std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::do_put(std::ostreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, char, double) const
   24,000,000 ( 0.10%)          0            0           12,000,000 ( 0.21%)      0              0           12,000,000 ( 0.34%)     0            0           /usr/include/c++/11/bits/stl_algobase.h:Particle::moveRandom(double, double, double, double, double, std::mersenne_twister_engine<unsigned long, 32ul, 624ul, 397ul, 31ul, 2567483615ul, 11ul, 4294967295ul, 7ul, 2636928640ul, 15ul, 4022730752ul, 18ul, 1812433253ul>&)
   23,979,732 ( 0.10%)          0            0                    0               0              0                    0              0            0           ./stdio-common/../include/rounding-mode.h:__printf_fp_l

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/juanb3ltran/Documentos/Universidad/Alto_rendimiento/Cream_drop/Main/utils.cpp
--------------------------------------------------------------------------------
Ir                   I1mr               ILmr       Dr                  D1mr            DLmr       Dw                  D1mw        DLmw        

          .                  .          .                   .               .          .                   .           .           .           #include "utils.hpp"
          .                  .          .                   .               .          .                   .           .           .           
          .                  .          .                   .               .          .                   .           .           .           //Implementación de funciones
 48,000,000 ( 0.20%)         2 ( 0.00%) 2 ( 0.08%)          0               0          0          30,000,000 ( 0.85%)  0           0           int getRandomInt(int max, std::mt19937& gen, bool positive) {
 12,000,000 ( 0.05%)         0          0                   0               0          0                   0           0           0               if (positive)
          .                  .          .                   .               .          .                   .           .           .               {
          .                  .          .                   .               .          .                   .           .           .                   std::uniform_int_distribution<int> dist_(0, max);
          .                  .          .                   .               .          .                   .           .           .                   return dist_(gen);
          .                  .          .                   .               .          .                   .           .           .               }
          .                  .          .                   .               .          .                   .           .           .               else
          .                  .          .                   .               .          .                   .           .           .               {
          .                  .          .                   .               .          .                   .           .           .                   std::uniform_int_distribution<int> dist_(-max, max);
          .                  .          .                   .               .          .                   .           .           .                   return dist_(gen);
          .                  .          .                   .               .          .                   .           .           .               }
          .                  .          .                   .               .          .                   .           .           .               
 36,000,000 ( 0.15%)         0          0          36,000,000 ( 0.62%)      0          0                   0           0           0           }
          .                  .          .                   .               .          .                   .           .           .           
         12 ( 0.00%)         1 ( 0.00%) 1 ( 0.04%)          0               0          0                   7 ( 0.00%)  0           0           void inicializar(std::vector<Particle> &balls, int N_particles, double Size, bool initCenter){
      1,203 ( 0.00%)         2 ( 0.00%) 2 ( 0.08%)          0               0          0                   0           0           0               for (int i = 0; i < N_particles; ++i) {
          .                  .          .                   .               .          .                   .           .           .                   balls.emplace_back(0, 0); // Cada partícula inicia en (0,0)
          .                  .          .                   .               .          .                   .           .           .               }
          .                  .          .                   .               .          .                   .           .           .           
          .                  .          .                   .               .          .                   .           .           .               // Si se quiere que empiecen en el centro, se salta esto, si no, sigue
          2 ( 0.00%)         1 ( 0.00%) 1 ( 0.04%)          0               0          0                   0           0           0               if (!initCenter){
          .                  .          .                   .               .          .                   .           .           .                   // Se genera el cuadrado inicial
          2 ( 0.00%)         1 ( 0.00%) 1 ( 0.04%)          1 ( 0.00%)      0          0                   0           0           0                   if(std::sqrt(N_particles) > Size){throw std::logic_error(" \n Particles can't fit in the container, increase its size or decrease number of particles.\n");}
          1 ( 0.00%)         0          0                   0               0          0                   0           0           0                   int square_size = std::sqrt(N_particles);
          5 ( 0.00%)         0          0                   0               0          0                   0           0           0                   if(square_size*square_size != balls.size()){throw std::logic_error(" \n  Number of particles does not form a perfect square.\n");}
          .                  .          .                   .               .          .                   .           .           .           
          2 ( 0.00%)         1 ( 0.00%) 1 ( 0.04%)          0               0          0                   0           0           0                   int i=0;
         66 ( 0.00%)         0          0                   0               0          0                   0           0           0                   for(double ix=0; ix < square_size; ix++){
      1,620 ( 0.00%)         0          0                   0               0          0                   0           0           0                       for (double iy=0; iy < square_size; iy++){            
        123 ( 0.00%)         0          0                   1 ( 0.00%)      0          0                   0           0           0                           balls[i].setX(ix - square_size/2);
        800 ( 0.00%)         0          0                   0               0          0                   0           0           0                           balls[i].setY(iy - square_size/2);
          .                  .          .                   .               .          .                   .           .           .                           // std::cout<< balls[i].getX() <<","<< balls[i].getY() <<std::endl;
        400 ( 0.00%)         0          0                   0               0          0                   0           0           0                           i++;
          .                  .          .                   .               .          .                   .           .           .                       }
          .                  .          .                   .               .          .                   .           .           .                   }     
          .                  .          .                   .               .          .                   .           .           .               }      
          8 ( 0.00%)         0          0                   7 ( 0.00%)      0          0                   0           0           0           }
          .                  .          .                   .               .          .                   .           .           .           
          .                  .          .                   .               .          .                   .           .           .           //Calcula la distancia RMS de las particulas desde el origen
          .                  .          .                   .               .          .                   .           .           .           double rms_distance(const std::vector<Particle> &walkers){
          .                  .          .                   .               .          .                   .           .           .               double square_sum = 0.0;
          .                  .          .                   .               .          .                   .           .           .               double x = 0.0, y = 0.0, norm = 0.0;
          .                  .          .                   .               .          .                   .           .           .               for(const Particle walker : walkers){
          .                  .          .                   .               .          .                   .           .           .                   x = walker.getX();
          .                  .          .                   .               .          .                   .           .           .                   y = walker.getY();
-- line 48 ----------------------------------------
-- line 53 ----------------------------------------
          .                  .          .                   .               .          .                   .           .           .               return std::sqrt(square_sum/walkers.size());
          .                  .          .                   .               .          .                   .           .           .           }
          .                  .          .                   .               .          .                   .           .           .           
          .                  .          .                   .               .          .                   .           .           .           //Funciones de entropía
          .                  .          .                   .               .          .                   .           .           .           
          .                  .          .                   .               .          .                   .           .           .           
          .                  .          .                   .               .          .                   .           .           .           void counts(std::unordered_map<int,int>& entropyGrid, double x, double y, 
          .                  .          .                   .               .          .                   .           .           .                       double x_min, double x_max, double y_min, double y_max, int divisions)
      2,000 ( 0.00%)         1 ( 0.00%) 1 ( 0.04%)        400 ( 0.00%)      0          0                 400 ( 0.00%)  0           0           {
          .                  .          .                   .               .          .                   .           .           .               //Calcula el tamaño de cada subdivision en terminos de las coordenadas de posicion
      1,600 ( 0.00%)         0          0                   0               0          0                   0           0           0               double x_step = (x_max - x_min) / static_cast<double>(divisions);
        800 ( 0.00%)         0          0                   0               0          0                   0           0           0               double y_step = (y_max - y_min) / static_cast<double>(divisions);
          .                  .          .                   .               .          .                   .           .           .           
          .                  .          .                   .               .          .                   .           .           .               //Verifica la posicion dentro de los limites
      3,200 ( 0.00%)         1 ( 0.00%) 1 ( 0.04%)          0               0          0                   0           0           0                   if ((x_min <= x) && (x <= x_max) && (y_min <= y) && (y <= y_max))
          .                  .          .                   .               .          .                   .           .           .                   {
          .                  .          .                   .               .          .                   .           .           .                       // Calcula el índice de la subdivisión para x e y
      1,200 ( 0.00%)         0          0                   0               0          0                   0           0           0                       int ix = int((x - x_min) / x_step);
      1,200 ( 0.00%)         1 ( 0.00%) 1 ( 0.04%)          0               0          0                   0           0           0                       int iy = int((y - y_min) / y_step);
          .                  .          .                   .               .          .                   .           .           .           
          .                  .          .                   .               .          .                   .           .           .                       // Se suma uno a ese índice (esa celda)
      1,600 ( 0.00%)         0          0                 400 ( 0.00%)      0          0                 400 ( 0.00%)  0           0                       entropyGrid[ix*divisions + iy]++;
          .                  .          .                   .               .          .                   .           .           .                   }
      2,400 ( 0.00%)         0          0               1,200 ( 0.00%)      0          0                   0           0           0           }
          .                  .          .                   .               .          .                   .           .           .           
          .                  .          .                   .               .          .                   .           .           .           double compute_entropy(std::unordered_map<int, int>& entropyGrid, int N_particles)
          3 ( 0.00%)         1 ( 0.00%) 1 ( 0.04%)          0               0          0                   1 ( 0.00%)  0           0           {
          .                  .          .                   .               .          .                   .           .           .               // Calcula la entropía
          1 ( 0.00%)         0          0                   0               0          0                   0           0           0               double entropy = 0.0;
          .                  .          .                   .               .          .                   .           .           .           
         10 ( 0.00%)         0          0                   0               0          0                   0           0           0               for (const auto& pair : entropyGrid) {
         20 ( 0.00%)         0          0                   8 ( 0.00%)      0          0                   5 ( 0.00%)  0           0                   double p = double(pair.second) / N_particles;
         28 ( 0.00%)         1 ( 0.00%) 1 ( 0.04%)          8 ( 0.00%)      0          0                   8 ( 0.00%)  0           0                   entropy -= p * std::log(p);
          .                  .          .                   .               .          .                   .           .           .               }
          .                  .          .                   .               .          .                   .           .           .           
          .                  .          .                   .               .          .                   .           .           .               return entropy;
          4 ( 0.00%)         0          0                   2 ( 0.00%)      0          0                   0           0           0           }
          .                  .          .                   .               .          .                   .           .           .           
          .                  .          .                   .               .          .                   .           .           .           
          .                  .          .                   .               .          .                   .           .           .           double delta_entropy(std::unordered_map<int, int>& entropyGrid, double new_x, double new_y, 
          .                  .          .                   .               .          .                   .           .           .                               double x_min, double x_max, double y_min, double y_max, int divisions, double old_x, double old_y, int N_particles)
 84,000,000 ( 0.36%) 6,000,001 ( 2.86%) 1 ( 0.04%)  6,000,000 ( 0.10%)      0          0          42,000,000 ( 1.19%)  0           0           {
          .                  .          .                   .               .          .                   .           .           .               //Calcula el cambio en la entropia teniendo en cuenta la subdivision de donde sale y a que llega una particula
          .                  .          .                   .               .          .                   .           .           .           
 24,000,000 ( 0.10%)         0          0                   0               0          0                   0           0           0               double x_step = (x_max - x_min) / divisions;
 12,000,000 ( 0.05%)         1 ( 0.00%) 1 ( 0.04%)          0               0          0                   0           0           0               double y_step = (y_max - y_min) / divisions;
          .                  .          .                   .               .          .                   .           .           .           
 18,000,000 ( 0.08%)         0          0                   0               0          0                   0           0           0               int old_ix = int((old_x - x_min) / x_step); //Indices de la subdivision con la posicion anterior (origen)
 18,000,000 ( 0.08%)         0          0                   0               0          0                   0           0           0               int old_iy = int((old_y - y_min) / y_step);
          .                  .          .                   .               .          .                   .           .           .           
 18,000,000 ( 0.08%)         0          0                   0               0          0                   0           0           0               int new_ix = int((new_x - x_min) / x_step); //Indices de la subdivision con la posicion actual (destino)
 18,000,000 ( 0.08%)         0          0                   0               0          0                   0           0           0               int new_iy = int((new_y - y_min) / y_step);
          .                  .          .                   .               .          .                   .           .           .           
 23,705,880 ( 0.10%)         0          0                   0               0          0                   0           0           0               if ((old_ix == new_ix) && (old_iy == new_iy))
          .                  .          .                   .               .          .                   .           .           .               {
          .                  .          .                   .               .          .                   .           .           .                   //Si la particula no cambio de subdivision entonces la entropia no cambio
  5,852,940 ( 0.02%)         0          0                   0               0          0                   0           0           0                   return 0.0;
          .                  .          .                   .               .          .                   .           .           .               }
          .                  .          .                   .               .          .                   .           .           .               else //la particula cambio de subdivision por lo que se calcula los terminos de probabilidad antes y despues del cambio 
          .                  .          .                   .               .          .                   .           .           .               {   
  2,889,810 ( 0.01%)   288,981 ( 0.14%) 1 ( 0.04%)    288,981 ( 0.00%)      0          0             866,943 ( 0.02%)  0           0                   double old_p1 = double(entropyGrid[old_ix*divisions + old_iy]) / N_particles; //probabilidad antigua de la subdivision 1 (origen)
  2,311,848 ( 0.01%)         1 ( 0.00%) 1 ( 0.04%)    866,943 ( 0.01%)      0          0             577,962 ( 0.02%)  0           0                   double old_p2 = double(entropyGrid[new_ix*divisions + new_iy]) / N_particles; //probabilidad antigua de la subdivision 2 (destino) Si el índice no está en el mapa, su valor es 0 por default
          .                  .          .                   .               .          .                   .           .           .           
          .                  .          .                   .               .          .                   .           .           .                   // Ajusta el contador para la subdivision donde estaba la particula y a la cual llego
    577,962 ( 0.00%)         0          0             288,981 ( 0.00%)      0          0             288,981 ( 0.01%)  0           0                   entropyGrid[new_ix*divisions + new_iy]++;
    577,962 ( 0.00%)         0          0             288,981 ( 0.00%)      0          0             288,981 ( 0.01%)  0           0                   entropyGrid[old_ix*divisions + old_iy]--;
          .                  .          .                   .               .          .                   .           .           .                   
          .                  .          .                   .               .          .                   .           .           .           
  1,444,905 ( 0.01%)         0          0             577,962 ( 0.01%)      0          0             577,962 ( 0.02%)  0           0                   double new_p1 = double(entropyGrid[old_ix*divisions + old_iy]) / N_particles; //probabilidad nueva de la subdivision 1 (origen)
  1,155,924 ( 0.00%)         0          0             577,962 ( 0.01%)      0          0             288,981 ( 0.01%)  0           0                   double new_p2 = double(entropyGrid[new_ix*divisions + new_iy]) / N_particles; //probabilidad nueva de la subdivision 2 (destino)
          .                  .          .                   .               .          .                   .           .           .           
    288,981 ( 0.00%)         0          0                   0               0          0                   0           0           0                   double ds = 0;
          .                  .          .                   .               .          .                   .           .           .                   //old_p1*log(old_p1)-new_p1*log(new_p1) + old_p2*log(old_p2)-new_p2*log(new_p2); //Cambio en la entropia 
  4,623,696 ( 0.02%)         2 ( 0.00%) 2 ( 0.08%)    866,943 ( 0.01%)      0          0             866,943 ( 0.02%)  0           0                   if (old_p1!=0){ds+=old_p1*log(old_p1);}
  4,029,034 ( 0.02%)         1 ( 0.00%) 1 ( 0.04%)  1,438,225 ( 0.02%)      0          0             861,933 ( 0.02%)  0           0                   if (new_p1!=0){ds-=new_p1*log(new_p1);}
  4,028,434 ( 0.02%)         2 ( 0.00%) 1 ( 0.04%)  1,437,985 ( 0.02%)      0          0             861,753 ( 0.02%)  0           0                   if (old_p2!=0){ds+=old_p2*log(old_p2);}
  3,467,772 ( 0.01%)         0          0             577,962 ( 0.01%)      0          0             866,943 ( 0.02%)  0           0                   if (new_p2!=0){ds-=new_p2*log(new_p2);}
          .                  .          .                   .               .          .                   .           .           .                   return ds;
          .                  .          .                   .               .          .                   .           .           .               }    
 72,000,000 ( 0.31%) 5,711,019 ( 2.72%) 0          54,000,000 ( 0.93%)      0          0                   0           0           0           }
          .                  .          .                   .               .          .                   .           .           .           
          .                  .          .                   .               .          .                   .           .           .           //Implementación de la clase Particle
          .                  .          .                   .               .          .                   .           .           .           
        401 ( 0.00%)         0          0                   0               0          0                 400 ( 0.00%) 99 ( 3.45%) 99 ( 5.29%)  Particle::Particle(double initialX, double initialY): x(initialX), y(initialY){}
          .                  .          .                   .               .          .                   .           .           .           
 12,000,400 ( 0.05%)         1 ( 0.00%) 0                   0               0          0                   0           0           0           double Particle::getX() const{
 12,000,400 ( 0.05%)         0          0          12,000,400 ( 0.21%) 77,339 (34.39%) 0                   0           0           0               return x;
 12,000,400 ( 0.05%)         0          0          12,000,400 ( 0.21%)      0          0                   0           0           0           }
          .                  .          .                   .               .          .                   .           .           .           
 12,000,400 ( 0.05%)         1 ( 0.00%) 1 ( 0.04%)          0               0          0                   0           0           0           double Particle::getY() const{
 12,000,400 ( 0.05%)         0          0          12,000,400 ( 0.21%)      0          0                   0           0           0               return y;
 12,000,400 ( 0.05%)         0          0          12,000,400 ( 0.21%)      0          0                   0           0           0           }
          .                  .          .                   .               .          .                   .           .           .           
          .                  .          .                   .               .          .                   .           .           .           void Particle::setX(double newX){
  6,001,200 ( 0.03%)         0          0                   0               0          0           6,000,400 ( 0.17%)  0           0               x=newX;
          .                  .          .                   .               .          .                   .           .           .           }
          .                  .          .                   .               .          .                   .           .           .           
          .                  .          .                   .               .          .                   .           .           .           void Particle::setY(double newY){
          .                  .          .                   .               .          .                   .           .           .               y=newY;
          .                  .          .                   .               .          .                   .           .           .           }
          .                  .          .                   .               .          .                   .           .           .           
          .                  .          .                   .               .          .                   .           .           .           void Particle::move(double dx, double dy){
          .                  .          .                   .               .          .                   .           .           .               x+=dx;
          .                  .          .                   .               .          .                   .           .           .               y+=dy;
          .                  .          .                   .               .          .                   .           .           .           }
          .                  .          .                   .               .          .                   .           .           .           
          .                  .          .                   .               .          .                   .           .           .           // Otra función para el mov de las partículas
108,000,000 ( 0.46%)         2 ( 0.00%) 2 ( 0.08%)  6,000,000 ( 0.10%)      0          0          54,000,000 ( 1.54%)  0           0           void Particle::moveRandom(double delta, double x_min, double x_max, double y_min, double y_max, std::mt19937& gen){
          .                  .          .                   .               .          .                   .           .           .               
 36,000,000 ( 0.15%)         0          0           6,000,000 ( 0.10%)      0          0          24,000,000 ( 0.68%)  0           0                   std::vector<double> possibleMoves = {-delta, 0.0, delta};
          .                  .          .                   .               .          .                   .           .           .           
          .                  .          .                   .               .          .                   .           .           .                   // Se inicializan valores fuera de límites para garantizar que se haga el while de abajo
 48,000,000 ( 0.20%)         2 ( 0.00%) 1 ( 0.04%)  6,000,000 ( 0.10%)      0          0                   0           0           0                   double newX = x_min - delta*2;
          .                  .          .                   .               .          .                   .           .           .                   double newY = y_min - delta*2;
          .                  .          .                   .               .          .                   .           .           .           
          .                  .          .                   .               .          .                   .           .           .                   // Se hará este ciclo hasta que se encuentre una nueva posición válida para la partícula
          .                  .          .                   .               .          .                   .           .           .                   // Siempre habrá un movimiento posible (mínimo 3 creo)
108,280,799 ( 0.46%)         2 ( 0.00%) 2 ( 0.08%) 12,031,174 ( 0.21%)      0          0                   0           0           0                   while (newX <= x_min || newX >= x_max || newY <= y_min || newY >= y_max){
          .                  .          .                   .               .          .                   .           .           .                       int index0 = getRandomInt(possibleMoves.size() - 1, gen);
          .                  .          .                   .               .          .                   .           .           .                       int index1 = getRandomInt(possibleMoves.size() - 1, gen);
 24,119,916 ( 0.10%)         0          0          18,089,937 ( 0.31%)      0          0                   0           0           0                       newX = x + possibleMoves[index0];
  6,029,979 ( 0.03%)         0          0                   0               0          0                   0           0           0                       newY = y + possibleMoves[index1];
          .                  .          .                   .               .          .                   .           .           .                   }
          .                  .          .                   .               .          .                   .           .           .           
          .                  .          .                   .               .          .                   .           .           .                   // Se actualiza la posición
          .                  .          .                   .               .          .                   .           .           .                   setX(newX); setY(newY);
 42,000,000 ( 0.18%) 6,000,000 ( 2.86%) 1 ( 0.04%) 36,000,000 ( 0.62%)      0          0                   0           0           0           }
          .                  .          .                   .               .          .                   .           .           .           
          .                  .          .                   .               .          .                   .           .           .           
          .                  .          .                   .               .          .                   .           .           .           // Función para mover las partículas. Devuelve el estado de la partícula (0: dentro, 1: salió por el hueco)
          .                  .          .                   .               .          .                   .           .           .           int Particle::moveRandomwHole(double delta, double x_min, double x_max, double y_min, double y_max, std::vector<double> holeinWall, std::mt19937& gen){
          .                  .          .                   .               .          .                   .           .           .           
          .                  .          .                   .               .          .                   .           .           .               std::vector<double> possibleMoves = {-delta, 0.0, delta};
          .                  .          .                   .               .          .                   .           .           .               double newX;
          .                  .          .                   .               .          .                   .           .           .               double newY;
-- line 187 ----------------------------------------
-- line 209 ----------------------------------------
          .                  .          .                   .               .          .                   .           .           .                   }
          .                  .          .                   .               .          .                   .           .           .               }
          .                  .          .                   .               .          .                   .           .           .           }
          .                  .          .                   .               .          .                   .           .           .           
          .                  .          .                   .               .          .                   .           .           .           // Determina si la partícula salió por el hueco
          .                  .          .                   .               .          .                   .           .           .           bool goneThroughWhole(double x, double y, std::vector<double> holeinWall, double delta){
          .                  .          .                   .               .          .                   .           .           .               return (x > holeinWall[0]-delta && x < holeinWall[0]+delta + holeinWall[2] && y > holeinWall[1]);
          .                  .          .                   .               .          .                   .           .           .               // Se suma el delta para tener en cuenta los casos en los que la partícula esté cerca al hueco y salga en diagonal
          3 ( 0.00%)         0          0                   1 ( 0.00%)      0          0                   1 ( 0.00%)  0           0           }
          .                  .          .                   .               .          .                   .           .           .           

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/ostream
--------------------------------------------------------------------------------
Ir                  I1mr       ILmr       Dr                  D1mr         DLmr       Dw                 D1mw       DLmw       

-- line 213 ----------------------------------------
         .          .          .                   .            .          .                  .          .          .                  *  @param  __f A variable of builtin floating point type.
         .          .          .                   .            .          .                  .          .          .                  *  @return  @c *this if successful
         .          .          .                   .            .          .                  .          .          .                  *
         .          .          .                   .            .          .                  .          .          .                  *  These functions use the stream's current locale (specifically, the
         .          .          .                   .            .          .                  .          .          .                  *  @c num_get facet) to perform numeric formatting.
         .          .          .                   .            .          .                  .          .          .                 */
         .          .          .                   .            .          .                  .          .          .                 __ostream_type&
         .          .          .                   .            .          .                  .          .          .                 operator<<(double __f)
24,000,000 ( 0.10%) 0          0           6,000,000 ( 0.10%)   0          0          6,000,000 ( 0.17%) 0          0                 { return _M_insert(__f); }
         .          .          .                   .            .          .                  .          .          .           
         .          .          .                   .            .          .                  .          .          .                 __ostream_type&
         .          .          .                   .            .          .                  .          .          .                 operator<<(float __f)
         .          .          .                   .            .          .                  .          .          .                 {
         .          .          .                   .            .          .                  .          .          .           	// _GLIBCXX_RESOLVE_LIB_DEFECTS
         .          .          .                   .            .          .                  .          .          .           	// 117. basic_ostream uses nonexistent num_put member functions.
         .          .          .                   .            .          .                  .          .          .           	return _M_insert(static_cast<double>(__f));
         .          .          .                   .            .          .                  .          .          .                 }
-- line 229 ----------------------------------------
-- line 608 ----------------------------------------
         .          .          .                   .            .          .                  .          .          .             // Partial specializations
         .          .          .                   .            .          .                  .          .          .             template<typename _Traits>
         .          .          .                   .            .          .                  .          .          .               inline basic_ostream<char, _Traits>&
         .          .          .                   .            .          .                  .          .          .               operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
         .          .          .                   .            .          .                  .          .          .               {
         .          .          .                   .            .          .                  .          .          .                 if (!__s)
         .          .          .                   .            .          .                  .          .          .           	__out.setstate(ios_base::badbit);
         .          .          .                   .            .          .                  .          .          .                 else
24,000,001 ( 0.10%) 0          0                   0            0          0          6,000,000 ( 0.17%) 0          0           	__ostream_insert(__out, __s,
         .          .          .                   .            .          .                  .          .          .           			 static_cast<streamsize>(_Traits::length(__s)));
         .          .          .                   .            .          .                  .          .          .                 return __out;
         .          .          .                   .            .          .                  .          .          .               }
         .          .          .                   .            .          .                  .          .          .           
         .          .          .                   .            .          .                  .          .          .             // Signed and unsigned
         .          .          .                   .            .          .                  .          .          .             template<typename _Traits>
         .          .          .                   .            .          .                  .          .          .               inline basic_ostream<char, _Traits>&
         .          .          .                   .            .          .                  .          .          .               operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
-- line 624 ----------------------------------------
-- line 677 ----------------------------------------
         .          .          .                   .            .          .                  .          .          .              *  This manipulator is often mistakenly used when a simple newline is
         .          .          .                   .            .          .                  .          .          .              *  desired, leading to poor buffering performance.  See
         .          .          .                   .            .          .                  .          .          .              *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/streambufs.html#io.streambuf.buffering
         .          .          .                   .            .          .                  .          .          .              *  for more on this subject.
         .          .          .                   .            .          .                  .          .          .             */
         .          .          .                   .            .          .                  .          .          .             template<typename _CharT, typename _Traits>
         .          .          .                   .            .          .                  .          .          .               inline basic_ostream<_CharT, _Traits>&
         .          .          .                   .            .          .                  .          .          .               endl(basic_ostream<_CharT, _Traits>& __os)
42,000,000 ( 0.18%) 1 ( 0.00%) 0          24,000,000 ( 0.41%) 766 ( 0.34%) 0          6,000,000 ( 0.17%) 0          0               { return flush(__os.put(__os.widen('\n'))); }
         .          .          .                   .            .          .                  .          .          .           
         .          .          .                   .            .          .                  .          .          .             /**
         .          .          .                   .            .          .                  .          .          .              *  @brief  Write a null character into the output sequence.
         .          .          .                   .            .          .                  .          .          .              *
         .          .          .                   .            .          .                  .          .          .              *  <em>Null character</em> is @c CharT() by definition.  For CharT
         .          .          .                   .            .          .                  .          .          .              *  of @c char, this correctly writes the ASCII @c NUL character
         .          .          .                   .            .          .                  .          .          .              *  string terminator.
         .          .          .                   .            .          .                  .          .          .             */
-- line 693 ----------------------------------------
-- line 699 ----------------------------------------
         .          .          .                   .            .          .                  .          .          .             /**
         .          .          .                   .            .          .                  .          .          .              *  @brief  Flushes the output stream.
         .          .          .                   .            .          .                  .          .          .              *
         .          .          .                   .            .          .                  .          .          .              *  This manipulator simply calls the stream's @c flush() member function.
         .          .          .                   .            .          .                  .          .          .             */
         .          .          .                   .            .          .                  .          .          .             template<typename _CharT, typename _Traits>
         .          .          .                   .            .          .                  .          .          .               inline basic_ostream<_CharT, _Traits>&
         .          .          .                   .            .          .                  .          .          .               flush(basic_ostream<_CharT, _Traits>& __os)
 6,000,000 ( 0.03%) 0          0                   0            0          0          6,000,000 ( 0.17%) 0          0               { return __os.flush(); }
         .          .          .                   .            .          .                  .          .          .           
         .          .          .                   .            .          .                  .          .          .           #if __cplusplus >= 201103L
         .          .          .                   .            .          .                  .          .          .             // C++11 27.7.3.9 Rvalue stream insertion [ostream.rvalue]
         .          .          .                   .            .          .                  .          .          .             // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .          .          .                   .            .          .                  .          .          .             // 1203. More useful rvalue stream insertion
         .          .          .                   .            .          .                  .          .          .           
         .          .          .                   .            .          .                  .          .          .           #if __cpp_lib_concepts
         .          .          .                   .            .          .                  .          .          .             // Use concepts if possible because they're cheaper to evaluate.
-- line 715 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/random.tcc
--------------------------------------------------------------------------------
Ir                  I1mr       ILmr       Dr                  D1mr            DLmr       Dw                  D1mw        DLmw       

-- line 319 ----------------------------------------
         .          .          .                   .               .          .                   .           .          .           	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
         .          .          .                   .               .          .                   .           .          .           	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
         .          .          .                   .               .          .                   .           .          .           	   _UIntType __f>
         .          .          .                   .               .          .                   .           .          .               void
         .          .          .                   .               .          .                   .           .          .               mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
         .          .          .                   .               .          .                   .           .          .           			    __s, __b, __t, __c, __l, __f>::
         .          .          .                   .               .          .                   .           .          .               seed(result_type __sd)
         .          .          .                   .               .          .                   .           .          .               {
         1 ( 0.00%) 0          0                   0               0          0                   1 ( 0.00%)  1 ( 0.03%) 0                 _M_x[0] = __detail::__mod<_UIntType,
         .          .          .                   .               .          .                   .           .          .           	__detail::_Shift<_UIntType, __w>::__value>(__sd);
         .          .          .                   .               .          .                   .           .          .           
     1,870 ( 0.00%) 0          0                   0               0          0                   0           0          0                 for (size_t __i = 1; __i < state_size; ++__i)
         .          .          .                   .               .          .                   .           .          .           	{
         .          .          .                   .               .          .                   .           .          .           	  _UIntType __x = _M_x[__i - 1];
     1,869 ( 0.00%) 0          0                   0               0          0                   0           0          0           	  __x ^= __x >> (__w - 2);
       623 ( 0.00%) 1 ( 0.00%) 1 ( 0.04%)          0               0          0                   0           0          0           	  __x *= __f;
         .          .          .                   .               .          .                   .           .          .           	  __x += __detail::__mod<_UIntType, __n>(__i);
       623 ( 0.00%) 0          0                   0               0          0                 623 ( 0.00%) 57 ( 1.99%) 0           	  _M_x[__i] = __detail::__mod<_UIntType,
         .          .          .                   .               .          .                   .           .          .           	    __detail::_Shift<_UIntType, __w>::__value>(__x);
         .          .          .                   .               .          .                   .           .          .           	}
         1 ( 0.00%) 0          0                   0               0          0                   1 ( 0.00%)  0          0                 _M_p = state_size;
         .          .          .                   .               .          .                   .           .          .               }
         .          .          .                   .               .          .                   .           .          .           
         .          .          .                   .               .          .                   .           .          .             template<typename _UIntType,
         .          .          .                   .               .          .                   .           .          .           	   size_t __w, size_t __n, size_t __m, size_t __r,
         .          .          .                   .               .          .                   .           .          .           	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
         .          .          .                   .               .          .                   .           .          .           	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
         .          .          .                   .               .          .                   .           .          .           	   _UIntType __f>
         .          .          .                   .               .          .                   .           .          .               template<typename _Sseq>
-- line 347 ----------------------------------------
-- line 386 ----------------------------------------
         .          .          .                   .               .          .                   .           .          .                 }
         .          .          .                   .               .          .                   .           .          .           
         .          .          .                   .               .          .                   .           .          .             template<typename _UIntType, size_t __w,
         .          .          .                   .               .          .                   .           .          .           	   size_t __n, size_t __m, size_t __r,
         .          .          .                   .               .          .                   .           .          .           	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
         .          .          .                   .               .          .                   .           .          .           	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
         .          .          .                   .               .          .                   .           .          .           	   _UIntType __f>
         .          .          .                   .               .          .                   .           .          .               void
   144,715 ( 0.00%) 1 ( 0.00%) 1 ( 0.04%)     28,943 ( 0.00%)      0          0                   0           0          0               mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
         .          .          .                   .               .          .                   .           .          .           			    __s, __b, __t, __c, __l, __f>::
         .          .          .                   .               .          .                   .           .          .               _M_gen_rand(void)
         .          .          .                   .               .          .                   .           .          .               {
         .          .          .                   .               .          .                   .           .          .                 const _UIntType __upper_mask = (~_UIntType()) << __r;
         .          .          .                   .               .          .                   .           .          .                 const _UIntType __lower_mask = ~__upper_mask;
         .          .          .                   .               .          .                   .           .          .           
19,768,069 ( 0.08%) 1 ( 0.00%) 1 ( 0.04%)     28,943 ( 0.00%)      0          0                   0           0          0                 for (size_t __k = 0; __k < (__n - __m); ++__k)
         .          .          .                   .               .          .                   .           .          .                   {
19,710,183 ( 0.08%) 1 ( 0.00%) 1 ( 0.04%)          0               0          0                   0           0          0           	  _UIntType __y = ((_M_x[__k] & __upper_mask)
19,710,183 ( 0.08%) 0          0           6,570,061 ( 0.11%) 37,539 (16.69%) 0                   0           0          0           			   | (_M_x[__k + 1] & __lower_mask));
26,280,244 ( 0.11%) 0          0           6,570,061 ( 0.11%) 15,293 ( 6.80%) 0           6,570,061 ( 0.19%)  0          0           	  _M_x[__k] = (_M_x[__k + __m] ^ (__y >> 1)
16,510,662 ( 0.07%) 0          0                   0               0          0                   0           0          0           		       ^ ((__y & 0x01) ? __a : 0));
         .          .          .                   .               .          .                   .           .          .                   }
         .          .          .                   .               .          .                   .           .          .           
34,384,284 ( 0.15%) 0          0                   0               0          0                   0           0          0                 for (size_t __k = (__n - __m); __k < (__n - 1); ++__k)
         .          .          .                   .               .          .                   .           .          .           	{
34,384,284 ( 0.15%) 0          0                   0               0          0                   0           0          0           	  _UIntType __y = ((_M_x[__k] & __upper_mask)
34,384,284 ( 0.15%) 0          0          11,461,428 ( 0.20%)      4 ( 0.00%) 0                   0           0          0           			   | (_M_x[__k + 1] & __lower_mask));
45,845,712 ( 0.19%) 2 ( 0.00%) 1 ( 0.04%) 11,461,428 ( 0.20%)      0          0          11,461,428 ( 0.33%)  0          0           	  _M_x[__k] = (_M_x[__k + (__m - __n)] ^ (__y >> 1)
28,714,257 ( 0.12%) 0          0                   0               0          0                   0           0          0           		       ^ ((__y & 0x01) ? __a : 0));
         .          .          .                   .               .          .                   .           .          .           	}
         .          .          .                   .               .          .                   .           .          .           
    86,829 ( 0.00%) 0          0              28,943 ( 0.00%)      0          0                   0           0          0                 _UIntType __y = ((_M_x[__n - 1] & __upper_mask)
    57,886 ( 0.00%) 0          0              28,943 ( 0.00%)      0          0                   0           0          0           		       | (_M_x[0] & __lower_mask));
   115,772 ( 0.00%) 1 ( 0.00%) 0              28,943 ( 0.00%)      0          0              28,943 ( 0.00%)  0          0                 _M_x[__n - 1] = (_M_x[__m - 1] ^ (__y >> 1)
    86,988 ( 0.00%) 0          0                   0               0          0                   0           0          0           		       ^ ((__y & 0x01) ? __a : 0));
    28,943 ( 0.00%) 0          0                   0               0          0              28,943 ( 0.00%)  0          0                 _M_p = 0;
    28,943 ( 0.00%) 0          0              28,943 ( 0.00%)      0          0                   0           0          0               }
         .          .          .                   .               .          .                   .           .          .           
         .          .          .                   .               .          .                   .           .          .             template<typename _UIntType, size_t __w,
         .          .          .                   .               .          .                   .           .          .           	   size_t __n, size_t __m, size_t __r,
         .          .          .                   .               .          .                   .           .          .           	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
         .          .          .                   .               .          .                   .           .          .           	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
         .          .          .                   .               .          .                   .           .          .           	   _UIntType __f>
         .          .          .                   .               .          .                   .           .          .               void
         .          .          .                   .               .          .                   .           .          .               mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
-- line 430 ----------------------------------------
-- line 447 ----------------------------------------
         .          .          .                   .               .          .                   .           .          .               typename
         .          .          .                   .               .          .                   .           .          .               mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
         .          .          .                   .               .          .                   .           .          .           			    __s, __b, __t, __c, __l, __f>::result_type
         .          .          .                   .               .          .                   .           .          .               mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
         .          .          .                   .               .          .                   .           .          .           			    __s, __b, __t, __c, __l, __f>::
         .          .          .                   .               .          .                   .           .          .               operator()()
         .          .          .                   .               .          .                   .           .          .               {
         .          .          .                   .               .          .                   .           .          .                 // Reload the vector - cost is O(n) amortized over n calls.
54,179,874 ( 0.23%) 5 ( 0.00%) 4 ( 0.16%) 18,059,958 ( 0.31%)      0          0                   0           0          0                 if (_M_p >= state_size)
    40,635 ( 0.00%) 2 ( 0.00%) 2 ( 0.08%)          0               0          0              28,943 ( 0.00%)  0          0           	_M_gen_rand();
         .          .          .                   .               .          .                   .           .          .           
         .          .          .                   .               .          .                   .           .          .                 // Calculate o(x(i)).
54,237,760 ( 0.23%) 0          0          18,088,901 ( 0.31%) 39,777 (17.69%) 0          18,059,958 ( 0.51%)  0          0                 result_type __z = _M_x[_M_p++];
72,239,832 ( 0.31%) 0          0                   0               0          0                   0           0          0                 __z ^= (__z >> __u) & __d;
72,239,832 ( 0.31%) 0          0                   0               0          0                   0           0          0                 __z ^= (__z << __s) & __b;
72,239,832 ( 0.31%) 0          0                   0               0          0                   0           0          0                 __z ^= (__z << __t) & __c;
54,179,874 ( 0.23%) 4 ( 0.00%) 2 ( 0.08%)          0               0          0                   0           0          0                 __z ^= (__z >> __l);
         .          .          .                   .               .          .                   .           .          .           
         .          .          .                   .               .          .                   .           .          .                 return __z;
         .          .          .                   .               .          .                   .           .          .               }
         .          .          .                   .               .          .                   .           .          .           
         .          .          .                   .               .          .                   .           .          .             template<typename _UIntType, size_t __w,
         .          .          .                   .               .          .                   .           .          .           	   size_t __n, size_t __m, size_t __r,
         .          .          .                   .               .          .                   .           .          .           	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
         .          .          .                   .               .          .                   .           .          .           	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
-- line 471 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/ext/new_allocator.h
--------------------------------------------------------------------------------
Ir                  I1mr       ILmr       Dr                  D1mr       DLmr       Dw                 D1mw       DLmw       

-- line 103 ----------------------------------------
         .          .          .                   .          .          .                  .          .          .                 allocate(size_type __n, const void* = static_cast<const void*>(0))
         .          .          .                   .          .          .                  .          .          .                 {
         .          .          .                   .          .          .                  .          .          .           #if __cplusplus >= 201103L
         .          .          .                   .          .          .                  .          .          .           	 // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .          .          .                   .          .          .                  .          .          .           	 // 3308. std::allocator<void>().allocate(n)
         .          .          .                   .          .          .                  .          .          .           	 static_assert(sizeof(_Tp) != 0, "cannot allocate incomplete types");
         .          .          .                   .          .          .                  .          .          .           #endif
         .          .          .                   .          .          .                  .          .          .           
        16 ( 0.00%) 1 ( 0.00%) 1 ( 0.04%)          0          0          0                  0          0          0           	if (__builtin_expect(__n > this->_M_max_size(), false))
         .          .          .                   .          .          .                  .          .          .           	  {
         .          .          .                   .          .          .                  .          .          .           	    // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .          .          .                   .          .          .                  .          .          .           	    // 3190. allocator::allocate sometimes returns too little storage
         .          .          .                   .          .          .                  .          .          .           	    if (__n > (std::size_t(-1) / sizeof(_Tp)))
         .          .          .                   .          .          .                  .          .          .           	      std::__throw_bad_array_new_length();
         .          .          .                   .          .          .                  .          .          .           	    std::__throw_bad_alloc();
         .          .          .                   .          .          .                  .          .          .           	  }
         .          .          .                   .          .          .                  .          .          .           
         .          .          .                   .          .          .                  .          .          .           #if __cpp_aligned_new
         .          .          .                   .          .          .                  .          .          .           	if (alignof(_Tp) > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
         .          .          .                   .          .          .                  .          .          .           	  {
         .          .          .                   .          .          .                  .          .          .           	    std::align_val_t __al = std::align_val_t(alignof(_Tp));
         .          .          .                   .          .          .                  .          .          .           	    return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), __al));
         .          .          .                   .          .          .                  .          .          .           	  }
         .          .          .                   .          .          .                  .          .          .           #endif
18,000,338 ( 0.08%) 4 ( 0.00%) 3 ( 0.12%)         20 ( 0.00%) 0          0          6,000,108 ( 0.17%) 0          0           	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
         .          .          .                   .          .          .                  .          .          .                 }
         .          .          .                   .          .          .                  .          .          .           
         .          .          .                   .          .          .                  .          .          .                 // __p is not permitted to be a null pointer.
         .          .          .                   .          .          .                  .          .          .                 void
         9 ( 0.00%) 0          0                   0          0          0                  9 ( 0.00%) 0          0                 deallocate(_Tp* __p, size_type __t __attribute__ ((__unused__)))
         .          .          .                   .          .          .                  .          .          .                 {
         .          .          .                   .          .          .                  .          .          .           #if __cpp_aligned_new
         .          .          .                   .          .          .                  .          .          .           	if (alignof(_Tp) > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
         .          .          .                   .          .          .                  .          .          .           	  {
         .          .          .                   .          .          .                  .          .          .           	    ::operator delete(__p,
         .          .          .                   .          .          .                  .          .          .           # if __cpp_sized_deallocation
         .          .          .                   .          .          .                  .          .          .           			      __t * sizeof(_Tp),
         .          .          .                   .          .          .                  .          .          .           # endif
         .          .          .                   .          .          .                  .          .          .           			      std::align_val_t(alignof(_Tp)));
         .          .          .                   .          .          .                  .          .          .           	    return;
         .          .          .                   .          .          .                  .          .          .           	  }
         .          .          .                   .          .          .                  .          .          .           #endif
36,000,191 ( 0.15%) 0          0          12,000,018 ( 0.21%) 0          0                 86 ( 0.00%) 0          0           	::operator delete(__p
         .          .          .                   .          .          .                  .          .          .           #if __cpp_sized_deallocation
         .          .          .                   .          .          .                  .          .          .           			  , __t * sizeof(_Tp)
         .          .          .                   .          .          .                  .          .          .           #endif
         .          .          .                   .          .          .                  .          .          .           			 );
         .          .          .                   .          .          .                  .          .          .                 }
         .          .          .                   .          .          .                  .          .          .           
         .          .          .                   .          .          .                  .          .          .           #if __cplusplus <= 201703L
         .          .          .                   .          .          .                  .          .          .                 size_type
         .          .          .                   .          .          .                  .          .          .                 max_size() const _GLIBCXX_USE_NOEXCEPT
         .          .          .                   .          .          .                  .          .          .                 { return _M_max_size(); }
         .          .          .                   .          .          .                  .          .          .           
         .          .          .                   .          .          .                  .          .          .           #if __cplusplus >= 201103L
         .          .          .                   .          .          .                  .          .          .                 template<typename _Up, typename... _Args>
         .          .          .                   .          .          .                  .          .          .           	void
       511 ( 0.00%) 0          0                 511 ( 0.00%) 0          0                  0          0          0           	construct(_Up* __p, _Args&&... __args)
         .          .          .                   .          .          .                  .          .          .           	noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)
         .          .          .                   .          .          .                  .          .          .           	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
         .          .          .                   .          .          .                  .          .          .           
         .          .          .                   .          .          .                  .          .          .                 template<typename _Up>
         .          .          .                   .          .          .                  .          .          .           	void
         .          .          .                   .          .          .                  .          .          .           	destroy(_Up* __p)
         .          .          .                   .          .          .                  .          .          .           	noexcept(std::is_nothrow_destructible<_Up>::value)
         .          .          .                   .          .          .                  .          .          .           	{ __p->~_Up(); }
-- line 168 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/stl_vector.h
--------------------------------------------------------------------------------
Ir                  I1mr       ILmr       Dr                  D1mr       DLmr       Dw         D1mw       DLmw       

-- line 90 ----------------------------------------
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .                 struct _Vector_impl_data
         .          .          .                   .          .          .          .          .          .                 {
         .          .          .                   .          .          .          .          .          .           	pointer _M_start;
         .          .          .                   .          .          .          .          .          .           	pointer _M_finish;
         .          .          .                   .          .          .          .          .          .           	pointer _M_end_of_storage;
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .           	_Vector_impl_data() _GLIBCXX_NOEXCEPT
         4 ( 0.00%) 1 ( 0.00%) 1 ( 0.04%)          0          0          0          2 ( 0.00%) 0          0           	: _M_start(), _M_finish(), _M_end_of_storage()
         .          .          .                   .          .          .          .          .          .           	{ }
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .           #if __cplusplus >= 201103L
         .          .          .                   .          .          .          .          .          .           	_Vector_impl_data(_Vector_impl_data&& __x) noexcept
         .          .          .                   .          .          .          .          .          .           	: _M_start(__x._M_start), _M_finish(__x._M_finish),
         .          .          .                   .          .          .          .          .          .           	  _M_end_of_storage(__x._M_end_of_storage)
         .          .          .                   .          .          .          .          .          .           	{ __x._M_start = __x._M_finish = __x._M_end_of_storage = pointer(); }
         .          .          .                   .          .          .          .          .          .           #endif
-- line 106 ----------------------------------------
-- line 328 ----------------------------------------
         .          .          .                   .          .          .          .          .          .                 _Vector_base(const allocator_type& __a, _Vector_base&& __x)
         .          .          .                   .          .          .          .          .          .                 : _M_impl(_Tp_alloc_type(__a), std::move(__x._M_impl))
         .          .          .                   .          .          .          .          .          .                 { }
         .          .          .                   .          .          .          .          .          .           #endif
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .                 ~_Vector_base() _GLIBCXX_NOEXCEPT
         .          .          .                   .          .          .          .          .          .                 {
         .          .          .                   .          .          .          .          .          .           	_M_deallocate(_M_impl._M_start,
         2 ( 0.00%) 1 ( 0.00%) 1 ( 0.04%)          1 ( 0.00%) 0          0          0          0          0           		      _M_impl._M_end_of_storage - _M_impl._M_start);
         .          .          .                   .          .          .          .          .          .                 }
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .               public:
         .          .          .                   .          .          .          .          .          .                 _Vector_impl _M_impl;
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .                 pointer
         .          .          .                   .          .          .          .          .          .                 _M_allocate(size_t __n)
         .          .          .                   .          .          .          .          .          .                 {
         .          .          .                   .          .          .          .          .          .           	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
        20 ( 0.00%) 0          0                   0          0          0          0          0          0           	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
         .          .          .                   .          .          .          .          .          .                 }
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .                 void
         .          .          .                   .          .          .          .          .          .                 _M_deallocate(pointer __p, size_t __n)
         .          .          .                   .          .          .          .          .          .                 {
         .          .          .                   .          .          .          .          .          .           	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
        22 ( 0.00%) 0          0                   0          0          0          0          0          0           	if (__p)
         .          .          .                   .          .          .          .          .          .           	  _Tr::deallocate(_M_impl, __p, __n);
         .          .          .                   .          .          .          .          .          .                 }
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .               protected:
         .          .          .                   .          .          .          .          .          .                 void
         .          .          .                   .          .          .          .          .          .                 _M_create_storage(size_t __n)
         .          .          .                   .          .          .          .          .          .                 {
         .          .          .                   .          .          .          .          .          .           	this->_M_impl._M_start = this->_M_allocate(__n);
-- line 361 ----------------------------------------
-- line 672 ----------------------------------------
         .          .          .                   .          .          .          .          .          .                 /**
         .          .          .                   .          .          .          .          .          .                  *  The dtor only erases the elements, and note that if the
         .          .          .                   .          .          .          .          .          .                  *  elements themselves are pointers, the pointed-to memory is
         .          .          .                   .          .          .          .          .          .                  *  not touched in any way.  Managing the pointer is the user's
         .          .          .                   .          .          .          .          .          .                  *  responsibility.
         .          .          .                   .          .          .          .          .          .                  */
         .          .          .                   .          .          .          .          .          .                 ~vector() _GLIBCXX_NOEXCEPT
         .          .          .                   .          .          .          .          .          .                 {
         1 ( 0.00%) 0          0                   1 ( 0.00%) 0          0          0          0          0           	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
         .          .          .                   .          .          .          .          .          .           		      _M_get_Tp_allocator());
         .          .          .                   .          .          .          .          .          .           	_GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC;
         .          .          .                   .          .          .          .          .          .                 }
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .                 /**
         .          .          .                   .          .          .          .          .          .                  *  @brief  %Vector assignment operator.
         .          .          .                   .          .          .          .          .          .                  *  @param  __x  A %vector of identical element and allocator types.
         .          .          .                   .          .          .          .          .          .                  *
-- line 688 ----------------------------------------
-- line 911 ----------------------------------------
         .          .          .                   .          .          .          .          .          .                 crend() const noexcept
         .          .          .                   .          .          .          .          .          .                 { return const_reverse_iterator(begin()); }
         .          .          .                   .          .          .          .          .          .           #endif
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .                 // [23.2.4.2] capacity
         .          .          .                   .          .          .          .          .          .                 /**  Returns the number of elements in the %vector.  */
         .          .          .                   .          .          .          .          .          .                 size_type
         .          .          .                   .          .          .          .          .          .                 size() const _GLIBCXX_NOEXCEPT
        44 ( 0.00%) 1 ( 0.00%) 1 ( 0.04%)          2 ( 0.00%) 0          0          0          0          0                 { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .                 /**  Returns the size() of the largest possible %vector.  */
         .          .          .                   .          .          .          .          .          .                 size_type
         .          .          .                   .          .          .          .          .          .                 max_size() const _GLIBCXX_NOEXCEPT
         .          .          .                   .          .          .          .          .          .                 { return _S_max_size(_M_get_Tp_allocator()); }
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .           #if __cplusplus >= 201103L
         .          .          .                   .          .          .          .          .          .                 /**
-- line 927 ----------------------------------------
-- line 1038 ----------------------------------------
         .          .          .                   .          .          .          .          .          .                  *  Note that data access with this operator is unchecked and
         .          .          .                   .          .          .          .          .          .                  *  out_of_range lookups are not defined. (For checked lookups
         .          .          .                   .          .          .          .          .          .                  *  see at().)
         .          .          .                   .          .          .          .          .          .                  */
         .          .          .                   .          .          .          .          .          .                 reference
         .          .          .                   .          .          .          .          .          .                 operator[](size_type __n) _GLIBCXX_NOEXCEPT
         .          .          .                   .          .          .          .          .          .                 {
         .          .          .                   .          .          .          .          .          .           	__glibcxx_requires_subscript(__n);
66,000,000 ( 0.28%) 1 ( 0.00%) 1 ( 0.04%) 30,000,000 ( 0.52%) 0          0          0          0          0           	return *(this->_M_impl._M_start + __n);
         .          .          .                   .          .          .          .          .          .                 }
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .                 /**
         .          .          .                   .          .          .          .          .          .                  *  @brief  Subscript access to the data contained in the %vector.
         .          .          .                   .          .          .          .          .          .                  *  @param __n The index of the element for which data should be
         .          .          .                   .          .          .          .          .          .                  *  accessed.
         .          .          .                   .          .          .          .          .          .                  *  @return  Read-only (constant) reference to data.
         .          .          .                   .          .          .          .          .          .                  *
-- line 1054 ----------------------------------------
-- line 1750 ----------------------------------------
         .          .          .                   .          .          .          .          .          .                 _M_emplace_aux(const_iterator __position, value_type&& __v)
         .          .          .                   .          .          .          .          .          .                 { return _M_insert_rval(__position, std::move(__v)); }
         .          .          .                   .          .          .          .          .          .           #endif
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .                 // Called by _M_fill_insert, _M_insert_aux etc.
         .          .          .                   .          .          .          .          .          .                 size_type
         .          .          .                   .          .          .          .          .          .                 _M_check_len(size_type __n, const char* __s) const
         .          .          .                   .          .          .          .          .          .                 {
        72 ( 0.00%) 0          0                   0          0          0          0          0          0           	if (max_size() - size() < __n)
         .          .          .                   .          .          .          .          .          .           	  __throw_length_error(__N(__s));
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .           	const size_type __len = size() + (std::max)(size(), __n);
         .          .          .                   .          .          .          .          .          .           	return (__len < size() || __len > max_size()) ? max_size() : __len;
         .          .          .                   .          .          .          .          .          .                 }
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .                 // Called by constructors to check initial size.
         .          .          .                   .          .          .          .          .          .                 static size_type
-- line 1766 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/uniform_int_dist.h
--------------------------------------------------------------------------------
Ir                   I1mr       ILmr       Dr                  D1mr       DLmr       Dw                  D1mw       DLmw       

-- line 185 ----------------------------------------
          .          .          .                   .          .          .                   .          .          .                 { return this->b(); }
          .          .          .                   .          .          .                   .          .          .           
          .          .          .                   .          .          .                   .          .          .                 /**
          .          .          .                   .          .          .                   .          .          .                  * @brief Generating functions.
          .          .          .                   .          .          .                   .          .          .                  */
          .          .          .                   .          .          .                   .          .          .                 template<typename _UniformRandomBitGenerator>
          .          .          .                   .          .          .                   .          .          .           	result_type
          .          .          .                   .          .          .                   .          .          .           	operator()(_UniformRandomBitGenerator& __urng)
 54,269,811 ( 0.23%) 0          0                   0          0          0          12,059,958 ( 0.34%) 0          0                   { return this->operator()(__urng, _M_param); }
          .          .          .                   .          .          .                   .          .          .           
          .          .          .                   .          .          .                   .          .          .                 template<typename _UniformRandomBitGenerator>
          .          .          .                   .          .          .                   .          .          .           	result_type
          .          .          .                   .          .          .                   .          .          .           	operator()(_UniformRandomBitGenerator& __urng,
          .          .          .                   .          .          .                   .          .          .           		   const param_type& __p);
          .          .          .                   .          .          .                   .          .          .           
          .          .          .                   .          .          .                   .          .          .                 template<typename _ForwardIterator,
          .          .          .                   .          .          .                   .          .          .           	       typename _UniformRandomBitGenerator>
-- line 201 ----------------------------------------
-- line 250 ----------------------------------------
          .          .          .                   .          .          .                   .          .          .           	  static_assert(!_Up_traits::__is_signed, "U must be unsigned");
          .          .          .                   .          .          .                   .          .          .           	  static_assert(!_Wp_traits::__is_signed, "W must be unsigned");
          .          .          .                   .          .          .                   .          .          .           	  static_assert(_Wp_traits::__digits == (2 * _Up_traits::__digits),
          .          .          .                   .          .          .                   .          .          .           			"W must be twice as wide as U");
          .          .          .                   .          .          .                   .          .          .           
          .          .          .                   .          .          .                   .          .          .           	  // reference: Fast Random Integer Generation in an Interval
          .          .          .                   .          .          .                   .          .          .           	  // ACM Transactions on Modeling and Computer Simulation 29 (1), 2019
          .          .          .                   .          .          .                   .          .          .           	  // https://arxiv.org/abs/1805.10941
 18,059,958 ( 0.08%) 0          0                   0          0          0                   0          0          0           	  _Wp __product = _Wp(__g()) * _Wp(__range);
          .          .          .                   .          .          .                   .          .          .           	  _Up __low = _Up(__product);
 36,119,916 ( 0.15%) 0          0                   0          0          0                   0          0          0           	  if (__low < __range)
          .          .          .                   .          .          .                   .          .          .           	    {
          .          .          .                   .          .          .                   .          .          .           	      _Up __threshold = -__range % __range;
          .          .          .                   .          .          .                   .          .          .           	      while (__low < __threshold)
          .          .          .                   .          .          .                   .          .          .           		{
          .          .          .                   .          .          .                   .          .          .           		  __product = _Wp(__g()) * _Wp(__range);
          .          .          .                   .          .          .                   .          .          .           		  __low = _Up(__product);
          .          .          .                   .          .          .                   .          .          .           		}
          .          .          .                   .          .          .                   .          .          .           	    }
 30,119,916 ( 0.13%) 2 ( 0.00%) 1 ( 0.04%)          0          0          0                   0          0          0           	  return __product >> _Up_traits::__digits;
          .          .          .                   .          .          .                   .          .          .           	}
          .          .          .                   .          .          .                   .          .          .               };
          .          .          .                   .          .          .                   .          .          .           
          .          .          .                   .          .          .                   .          .          .             template<typename _IntType>
          .          .          .                   .          .          .                   .          .          .               template<typename _UniformRandomBitGenerator>
          .          .          .                   .          .          .                   .          .          .                 typename uniform_int_distribution<_IntType>::result_type
120,599,580 ( 0.51%) 1 ( 0.00%) 1 ( 0.04%)          0          0          0          72,359,748 ( 2.06%) 0          0                 uniform_int_distribution<_IntType>::
          .          .          .                   .          .          .                   .          .          .                 operator()(_UniformRandomBitGenerator& __urng,
          .          .          .                   .          .          .                   .          .          .           		 const param_type& __param)
          .          .          .                   .          .          .                   .          .          .                 {
          .          .          .                   .          .          .                   .          .          .           	typedef typename _UniformRandomBitGenerator::result_type _Gresult_type;
          .          .          .                   .          .          .                   .          .          .           	typedef typename make_unsigned<result_type>::type __utype;
          .          .          .                   .          .          .                   .          .          .           	typedef typename common_type<_Gresult_type, __utype>::type __uctype;
          .          .          .                   .          .          .                   .          .          .           
          .          .          .                   .          .          .                   .          .          .           	constexpr __uctype __urngmin = _UniformRandomBitGenerator::min();
          .          .          .                   .          .          .                   .          .          .           	constexpr __uctype __urngmax = _UniformRandomBitGenerator::max();
          .          .          .                   .          .          .                   .          .          .           	static_assert( __urngmin < __urngmax,
          .          .          .                   .          .          .                   .          .          .           	    "Uniform random bit generator must define min() < max()");
          .          .          .                   .          .          .                   .          .          .           	constexpr __uctype __urngrange = __urngmax - __urngmin;
          .          .          .                   .          .          .                   .          .          .           
 12,059,958 ( 0.05%) 0          0                   0          0          0                   0          0          0           	const __uctype __urange
 12,059,958 ( 0.05%) 0          0                   0          0          0                   0          0          0           	  = __uctype(__param.b()) - __uctype(__param.a());
          .          .          .                   .          .          .                   .          .          .           
          .          .          .                   .          .          .                   .          .          .           	__uctype __ret;
 54,179,874 ( 0.23%) 0          0                   0          0          0                   0          0          0           	if (__urngrange > __urange)
          .          .          .                   .          .          .                   .          .          .           	  {
          .          .          .                   .          .          .                   .          .          .           	    // downscaling
          .          .          .                   .          .          .                   .          .          .           
 18,059,958 ( 0.08%) 0          0                   0          0          0                   0          0          0           	    const __uctype __uerange = __urange + 1; // __urange can be zero
          .          .          .                   .          .          .                   .          .          .           
          .          .          .                   .          .          .                   .          .          .           #if defined __UINT64_TYPE__ && defined __UINT32_TYPE__
          .          .          .                   .          .          .                   .          .          .           #if __SIZEOF_INT128__
          .          .          .                   .          .          .                   .          .          .           	    if _GLIBCXX17_CONSTEXPR (__urngrange == __UINT64_MAX__)
          .          .          .                   .          .          .                   .          .          .           	      {
          .          .          .                   .          .          .                   .          .          .           		// __urng produces values that use exactly 64-bits,
          .          .          .                   .          .          .                   .          .          .           		// so use 128-bit integers to downscale to desired range.
          .          .          .                   .          .          .                   .          .          .           		__UINT64_TYPE__ __u64erange = __uerange;
-- line 306 ----------------------------------------
-- line 307 ----------------------------------------
          .          .          .                   .          .          .                   .          .          .           		__ret = _S_nd<unsigned __int128>(__urng, __u64erange);
          .          .          .                   .          .          .                   .          .          .           	      }
          .          .          .                   .          .          .                   .          .          .           	    else
          .          .          .                   .          .          .                   .          .          .           #endif
          .          .          .                   .          .          .                   .          .          .           	    if _GLIBCXX17_CONSTEXPR (__urngrange == __UINT32_MAX__)
          .          .          .                   .          .          .                   .          .          .           	      {
          .          .          .                   .          .          .                   .          .          .           		// __urng produces values that use exactly 32-bits,
          .          .          .                   .          .          .                   .          .          .           		// so use 64-bit integers to downscale to desired range.
 18,059,958 ( 0.08%) 0          0                   0          0          0                   0          0          0           		__UINT32_TYPE__ __u32erange = __uerange;
          .          .          .                   .          .          .                   .          .          .           		__ret = _S_nd<__UINT64_TYPE__>(__urng, __u32erange);
          .          .          .                   .          .          .                   .          .          .           	      }
          .          .          .                   .          .          .                   .          .          .           	    else
          .          .          .                   .          .          .                   .          .          .           #endif
          .          .          .                   .          .          .                   .          .          .           	      {
          .          .          .                   .          .          .                   .          .          .           		// fallback case (2 divisions)
          .          .          .                   .          .          .                   .          .          .           		const __uctype __scaling = __urngrange / __uerange;
          .          .          .                   .          .          .                   .          .          .           		const __uctype __past = __uerange * __scaling;
-- line 323 ----------------------------------------
-- line 352 ----------------------------------------
          .          .          .                   .          .          .                   .          .          .           			 (__urng, param_type(0, __urange / __uerngrange)));
          .          .          .                   .          .          .                   .          .          .           		__ret = __tmp + (__uctype(__urng()) - __urngmin);
          .          .          .                   .          .          .                   .          .          .           	      }
          .          .          .                   .          .          .                   .          .          .           	    while (__ret > __urange || __ret < __tmp);
          .          .          .                   .          .          .                   .          .          .           	  }
          .          .          .                   .          .          .                   .          .          .           	else
          .          .          .                   .          .          .                   .          .          .           	  __ret = __uctype(__urng()) - __urngmin;
          .          .          .                   .          .          .                   .          .          .           
 18,059,958 ( 0.08%) 0          0                   0          0          0                   0          0          0           	return __ret + __param.a();
 96,479,664 ( 0.41%) 0          0          84,419,706 ( 1.46%) 0          0                   0          0          0                 }
          .          .          .                   .          .          .                   .          .          .           
          .          .          .                   .          .          .                   .          .          .           
          .          .          .                   .          .          .                   .          .          .             template<typename _IntType>
          .          .          .                   .          .          .                   .          .          .               template<typename _ForwardIterator,
          .          .          .                   .          .          .                   .          .          .           	     typename _UniformRandomBitGenerator>
          .          .          .                   .          .          .                   .          .          .                 void
          .          .          .                   .          .          .                   .          .          .                 uniform_int_distribution<_IntType>::
          .          .          .                   .          .          .                   .          .          .                 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
-- line 369 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/hashtable_policy.h
--------------------------------------------------------------------------------
Ir                  I1mr       ILmr       Dr                  D1mr       DLmr       Dw                  D1mw       DLmw       

-- line 211 ----------------------------------------
         .          .          .                   .          .          .                   .          .          .              *  template parameter of class template _Hashtable controls whether
         .          .          .                   .          .          .                   .          .          .              *  nodes also store a hash code. In some cases (e.g. strings) this
         .          .          .                   .          .          .                   .          .          .              *  may be a performance win.
         .          .          .                   .          .          .                   .          .          .              */
         .          .          .                   .          .          .                   .          .          .             struct _Hash_node_base
         .          .          .                   .          .          .                   .          .          .             {
         .          .          .                   .          .          .                   .          .          .               _Hash_node_base* _M_nxt;
         .          .          .                   .          .          .                   .          .          .           
        65 ( 0.00%) 0          0                   0          0          0                  65 ( 0.00%) 0          0               _Hash_node_base() noexcept : _M_nxt() { }
         .          .          .                   .          .          .                   .          .          .           
         .          .          .                   .          .          .                   .          .          .               _Hash_node_base(_Hash_node_base* __next) noexcept : _M_nxt(__next) { }
         .          .          .                   .          .          .                   .          .          .             };
         .          .          .                   .          .          .                   .          .          .           
         .          .          .                   .          .          .                   .          .          .             /**
         .          .          .                   .          .          .                   .          .          .              *  struct _Hash_node_value_base
         .          .          .                   .          .          .                   .          .          .              *
         .          .          .                   .          .          .                   .          .          .              *  Node type with the value to store.
-- line 227 ----------------------------------------
-- line 274 ----------------------------------------
         .          .          .                   .          .          .                   .          .          .              *  Primary template struct _Hash_node.
         .          .          .                   .          .          .                   .          .          .              */
         .          .          .                   .          .          .                   .          .          .             template<typename _Value, bool _Cache_hash_code>
         .          .          .                   .          .          .                   .          .          .               struct _Hash_node
         .          .          .                   .          .          .                   .          .          .               : _Hash_node_base
         .          .          .                   .          .          .                   .          .          .               , _Hash_node_value<_Value, _Cache_hash_code>
         .          .          .                   .          .          .                   .          .          .               {
         .          .          .                   .          .          .                   .          .          .                 _Hash_node*
       165 ( 0.00%) 0          0                   0          0          0                   0          0          0                 _M_next() const noexcept
       169 ( 0.00%) 0          0                 169 ( 0.00%) 3 ( 0.00%) 0                   0          0          0                 { return static_cast<_Hash_node*>(this->_M_nxt); }
         .          .          .                   .          .          .                   .          .          .               };
         .          .          .                   .          .          .                   .          .          .           
         .          .          .                   .          .          .                   .          .          .             /// Base class for node iterators.
         .          .          .                   .          .          .                   .          .          .             template<typename _Value, bool _Cache_hash_code>
         .          .          .                   .          .          .                   .          .          .               struct _Node_iterator_base
         .          .          .                   .          .          .                   .          .          .               {
         .          .          .                   .          .          .                   .          .          .                 using __node_type = _Hash_node<_Value, _Cache_hash_code>;
         .          .          .                   .          .          .                   .          .          .           
-- line 291 ----------------------------------------
-- line 422 ----------------------------------------
         .          .          .                   .          .          .                   .          .          .             {
         .          .          .                   .          .          .                   .          .          .               typedef std::size_t first_argument_type;
         .          .          .                   .          .          .                   .          .          .               typedef std::size_t second_argument_type;
         .          .          .                   .          .          .                   .          .          .               typedef std::size_t result_type;
         .          .          .                   .          .          .                   .          .          .           
         .          .          .                   .          .          .                   .          .          .               result_type
         .          .          .                   .          .          .                   .          .          .               operator()(first_argument_type __num,
         .          .          .                   .          .          .                   .          .          .           	       second_argument_type __den) const noexcept
 5,205,058 ( 0.02%) 1 ( 0.00%) 1 ( 0.04%)         59 ( 0.00%) 0          0                   0          0          0               { return __num % __den; }
         .          .          .                   .          .          .                   .          .          .             };
         .          .          .                   .          .          .                   .          .          .           
         .          .          .                   .          .          .                   .          .          .             /// Default ranged hash function H.  In principle it should be a
         .          .          .                   .          .          .                   .          .          .             /// function object composed from objects of type H1 and H2 such that
         .          .          .                   .          .          .                   .          .          .             /// h(k, N) = h2(h1(k), N), but that would mean making extra copies of
         .          .          .                   .          .          .                   .          .          .             /// h1 and h2.  So instead we'll just use a tag to tell class template
         .          .          .                   .          .          .                   .          .          .             /// hashtable to do that composition.
         .          .          .                   .          .          .                   .          .          .             struct _Default_ranged_hash { };
-- line 438 ----------------------------------------
-- line 439 ----------------------------------------
         .          .          .                   .          .          .                   .          .          .           
         .          .          .                   .          .          .                   .          .          .             /// Default value for rehash policy.  Bucket size is (usually) the
         .          .          .                   .          .          .                   .          .          .             /// smallest prime that keeps the load factor small enough.
         .          .          .                   .          .          .                   .          .          .             struct _Prime_rehash_policy
         .          .          .                   .          .          .                   .          .          .             {
         .          .          .                   .          .          .                   .          .          .               using __has_load_factor = true_type;
         .          .          .                   .          .          .                   .          .          .           
         .          .          .                   .          .          .                   .          .          .               _Prime_rehash_policy(float __z = 1.0) noexcept
         2 ( 0.00%) 0          0                   0          0          0                   2 ( 0.00%) 0          0               : _M_max_load_factor(__z), _M_next_resize(0) { }
         .          .          .                   .          .          .                   .          .          .           
         .          .          .                   .          .          .                   .          .          .               float
         .          .          .                   .          .          .                   .          .          .               max_load_factor() const noexcept
         .          .          .                   .          .          .                   .          .          .               { return _M_max_load_factor; }
         .          .          .                   .          .          .                   .          .          .           
         .          .          .                   .          .          .                   .          .          .               // Return a bucket size no smaller than n.
         .          .          .                   .          .          .                   .          .          .               std::size_t
         .          .          .                   .          .          .                   .          .          .               _M_next_bkt(std::size_t __n) const;
-- line 455 ----------------------------------------
-- line 715 ----------------------------------------
         .          .          .                   .          .          .                   .          .          .                 __node._M_node = nullptr;
         .          .          .                   .          .          .                   .          .          .                 return __pos->second;
         .          .          .                   .          .          .                   .          .          .               }
         .          .          .                   .          .          .                   .          .          .           
         .          .          .                   .          .          .                   .          .          .             template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
         .          .          .                   .          .          .                   .          .          .           	   typename _Hash, typename _RangeHash, typename _Unused,
         .          .          .                   .          .          .                   .          .          .           	   typename _RehashPolicy, typename _Traits>
         .          .          .                   .          .          .                   .          .          .               auto
20,811,432 ( 0.09%) 4 ( 0.00%) 2 ( 0.08%)  1,734,286 ( 0.03%) 0          0          10,405,716 ( 0.30%) 0          0               _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
         .          .          .                   .          .          .                   .          .          .           	      _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>::
         .          .          .                   .          .          .                   .          .          .               operator[](key_type&& __k)
         .          .          .                   .          .          .                   .          .          .               -> mapped_type&
         .          .          .                   .          .          .                   .          .          .               {
         .          .          .                   .          .          .                   .          .          .                 __hashtable* __h = static_cast<__hashtable*>(this);
         .          .          .                   .          .          .                   .          .          .                 __hash_code __code = __h->_M_hash_code(__k);
         .          .          .                   .          .          .                   .          .          .                 std::size_t __bkt = __h->_M_bucket_index(__code);
         .          .          .                   .          .          .                   .          .          .                 if (auto __node = __h->_M_find_node(__bkt, __k, __code))
 1,734,222 ( 0.01%) 0          0                   0          0          0                   0          0          0           	return __node->_M_v().second;
         .          .          .                   .          .          .                   .          .          .           
         .          .          .                   .          .          .                   .          .          .                 typename __hashtable::_Scoped_node __node {
         .          .          .                   .          .          .                   .          .          .           	__h,
         .          .          .                   .          .          .                   .          .          .           	std::piecewise_construct,
         .          .          .                   .          .          .                   .          .          .           	std::forward_as_tuple(std::move(__k)),
         .          .          .                   .          .          .                   .          .          .           	std::tuple<>()
         .          .          .                   .          .          .                   .          .          .                 };
         .          .          .                   .          .          .                   .          .          .                 auto __pos
         .          .          .                   .          .          .                   .          .          .           	= __h->_M_insert_unique_node(__bkt, __code, __node._M_node);
         .          .          .                   .          .          .                   .          .          .                 __node._M_node = nullptr;
        64 ( 0.00%) 0          0                   0          0          0                   0          0          0                 return __pos->second;
17,342,860 ( 0.07%) 0          0          13,874,288 ( 0.24%) 0          0                   0          0          0               }
         .          .          .                   .          .          .                   .          .          .           
         .          .          .                   .          .          .                   .          .          .             template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
         .          .          .                   .          .          .                   .          .          .           	   typename _Hash, typename _RangeHash, typename _Unused,
         .          .          .                   .          .          .                   .          .          .           	   typename _RehashPolicy, typename _Traits>
         .          .          .                   .          .          .                   .          .          .               auto
         .          .          .                   .          .          .                   .          .          .               _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
         .          .          .                   .          .          .                   .          .          .           	      _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>::
         .          .          .                   .          .          .                   .          .          .               at(const key_type& __k)
-- line 752 ----------------------------------------
-- line 1211 ----------------------------------------
         .          .          .                   .          .          .                   .          .          .           
         .          .          .                   .          .          .                   .          .          .                 _Hash_code_base(const _Hash& __hash) : __ebo_hash(__hash) { }
         .          .          .                   .          .          .                   .          .          .           
         .          .          .                   .          .          .                   .          .          .                 __hash_code
         .          .          .                   .          .          .                   .          .          .                 _M_hash_code(const _Key& __k) const
         .          .          .                   .          .          .                   .          .          .                 {
         .          .          .                   .          .          .                   .          .          .           	static_assert(__is_invocable<const _Hash&, const _Key&>{},
         .          .          .                   .          .          .                   .          .          .           	    "hash function must be invocable with an argument of key type");
 1,736,162 ( 0.01%) 0          0           1,735,224 ( 0.03%) 0          0                   0          0          0           	return _M_hash()(__k);
         .          .          .                   .          .          .                   .          .          .                 }
         .          .          .                   .          .          .                   .          .          .           
         .          .          .                   .          .          .                   .          .          .                 template<typename _Kt>
         .          .          .                   .          .          .                   .          .          .           	__hash_code
         .          .          .                   .          .          .                   .          .          .           	_M_hash_code_tr(const _Kt& __k) const
         .          .          .                   .          .          .                   .          .          .           	{
         .          .          .                   .          .          .                   .          .          .           	  static_assert(__is_invocable<const _Hash&, const _Kt&>{},
         .          .          .                   .          .          .                   .          .          .           	    "hash function must be invocable with an argument of key type");
-- line 1227 ----------------------------------------
-- line 1609 ----------------------------------------
         .          .          .                   .          .          .                   .          .          .           
         .          .          .                   .          .          .                   .          .          .                 bool
         .          .          .                   .          .          .                   .          .          .                 _M_equals(const _Key& __k, __hash_code __c,
         .          .          .                   .          .          .                   .          .          .           		const _Hash_node_value<_Value, __hash_cached::value>& __n) const
         .          .          .                   .          .          .                   .          .          .                 {
         .          .          .                   .          .          .                   .          .          .           	static_assert(__is_invocable<const _Equal&, const _Key&, const _Key&>{},
         .          .          .                   .          .          .                   .          .          .           	  "key equality predicate must be invocable with two arguments of "
         .          .          .                   .          .          .                   .          .          .           	  "key type");
 3,470,320 ( 0.01%) 0          0                   0          0          0                   0          0          0           	return _S_equals(__c, __n) && _M_eq()(__k, _ExtractKey{}(__n._M_v()));
         .          .          .                   .          .          .                   .          .          .                 }
         .          .          .                   .          .          .                   .          .          .           
         .          .          .                   .          .          .                   .          .          .                 template<typename _Kt>
         .          .          .                   .          .          .                   .          .          .           	bool
         .          .          .                   .          .          .                   .          .          .           	_M_equals_tr(const _Kt& __k, __hash_code __c,
         .          .          .                   .          .          .                   .          .          .           		     const _Hash_node_value<_Value,
         .          .          .                   .          .          .                   .          .          .           					    __hash_cached::value>& __n) const
         .          .          .                   .          .          .                   .          .          .           	{
-- line 1625 ----------------------------------------
-- line 1904 ----------------------------------------
         .          .          .                   .          .          .                   .          .          .                 __n->~__node_type();
         .          .          .                   .          .          .                   .          .          .                 __node_alloc_traits::deallocate(_M_node_allocator(), __ptr, 1);
         .          .          .                   .          .          .                   .          .          .               }
         .          .          .                   .          .          .                   .          .          .           
         .          .          .                   .          .          .                   .          .          .             template<typename _NodeAlloc>
         .          .          .                   .          .          .                   .          .          .               void
         .          .          .                   .          .          .                   .          .          .               _Hashtable_alloc<_NodeAlloc>::_M_deallocate_nodes(__node_ptr __n)
         .          .          .                   .          .          .                   .          .          .               {
       131 ( 0.00%) 0          0                   0          0          0                   0          0          0                 while (__n)
         .          .          .                   .          .          .                   .          .          .           	{
         .          .          .                   .          .          .                   .          .          .           	  __node_ptr __tmp = __n;
         .          .          .                   .          .          .                   .          .          .           	  __n = __n->_M_next();
         .          .          .                   .          .          .                   .          .          .           	  _M_deallocate_node(__tmp);
         .          .          .                   .          .          .                   .          .          .           	}
         .          .          .                   .          .          .                   .          .          .               }
         .          .          .                   .          .          .                   .          .          .           
         .          .          .                   .          .          .                   .          .          .             template<typename _NodeAlloc>
-- line 1920 ----------------------------------------
-- line 1921 ----------------------------------------
         .          .          .                   .          .          .                   .          .          .               auto
         .          .          .                   .          .          .                   .          .          .               _Hashtable_alloc<_NodeAlloc>::_M_allocate_buckets(std::size_t __bkt_count)
         .          .          .                   .          .          .                   .          .          .               -> __buckets_ptr
         .          .          .                   .          .          .                   .          .          .               {
         .          .          .                   .          .          .                   .          .          .                 __buckets_alloc_type __alloc(_M_node_allocator());
         .          .          .                   .          .          .                   .          .          .           
         .          .          .                   .          .          .                   .          .          .                 auto __ptr = __buckets_alloc_traits::allocate(__alloc, __bkt_count);
         .          .          .                   .          .          .                   .          .          .                 __buckets_ptr __p = std::__to_address(__ptr);
        16 ( 0.00%) 0          0                   0          0          0                   4 ( 0.00%) 0          0                 __builtin_memset(__p, 0, __bkt_count * sizeof(__node_base_ptr));
         .          .          .                   .          .          .                   .          .          .                 return __p;
         .          .          .                   .          .          .                   .          .          .               }
         .          .          .                   .          .          .                   .          .          .           
         .          .          .                   .          .          .                   .          .          .             template<typename _NodeAlloc>
         .          .          .                   .          .          .                   .          .          .               void
         .          .          .                   .          .          .                   .          .          .               _Hashtable_alloc<_NodeAlloc>::
         .          .          .                   .          .          .                   .          .          .               _M_deallocate_buckets(__buckets_ptr __bkts,
         .          .          .                   .          .          .                   .          .          .           			  std::size_t __bkt_count)
-- line 1937 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/juanb3ltran/Documentos/Universidad/Alto_rendimiento/Cream_drop/Main/main.cpp
--------------------------------------------------------------------------------
Ir                  I1mr       ILmr       Dr                  D1mr       DLmr       Dw                  D1mw       DLmw       

         .          .          .                   .          .          .                   .          .          .           #include "utils.hpp"
         .          .          .                   .          .          .                   .          .          .           
         .          .          .                   .          .          .                   .          .          .           
        13 ( 0.00%) 1 ( 0.00%) 1 ( 0.04%)          2 ( 0.00%) 1 ( 0.00%) 0                   7 ( 0.00%) 0          0           int main(int argc, char *argv[]) {
         .          .          .                   .          .          .                   .          .          .               //Declara variables
         .          .          .                   .          .          .                   .          .          .               int t_final, N_particles, divisions, seed;    
         .          .          .                   .          .          .                   .          .          .               double size, x_min, x_max, y_min, y_max;
         .          .          .                   .          .          .                   .          .          .           
         .          .          .                   .          .          .                   .          .          .               //lee el input asumiendo que cada valor tiene un comentario (que debe ser ignorado)
        10 ( 0.00%) 1 ( 0.00%) 1 ( 0.04%)          0          0          0                   2 ( 0.00%) 1 ( 0.03%) 0               std::cin >> N_particles; std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
         4 ( 0.00%) 0          0                   0          0          0                   1 ( 0.00%) 0          0               std::cin >> size; std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
         7 ( 0.00%) 0          0                   0          0          0                   2 ( 0.00%) 0          0               std::cin >> t_final; std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
         7 ( 0.00%) 1 ( 0.00%) 1 ( 0.04%)          0          0          0                   2 ( 0.00%) 0          0               std::cin >> divisions; std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
         7 ( 0.00%) 0          0                   0          0          0                   2 ( 0.00%) 0          0               std::cin >> seed; std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
         .          .          .                   .          .          .                   .          .          .           
         .          .          .                   .          .          .                   .          .          .               // limites del contenedor
         4 ( 0.00%) 0          0                   2 ( 0.00%) 1 ( 0.00%) 1 ( 0.01%)          2 ( 0.00%) 0          0               x_min=-size;
         .          .          .                   .          .          .                   .          .          .               x_max=size;
         .          .          .                   .          .          .                   .          .          .               y_min=-size;
         .          .          .                   .          .          .                   .          .          .               y_max=size;
         .          .          .                   .          .          .                   .          .          .           
         .          .          .                   .          .          .                   .          .          .               //Crea el vector de particulas y el generador aleatorio
         .          .          .                   .          .          .                   .          .          .               std::vector<Particle> balls;
         .          .          .                   .          .          .                   .          .          .               std::mt19937 gen(seed);
         .          .          .                   .          .          .                   .          .          .           
         .          .          .                   .          .          .                   .          .          .               // Inicializa n objetos de la clase Particle y los añade al vector
         5 ( 0.00%) 0          0                   2 ( 0.00%) 0          0                   1 ( 0.00%) 0          0               inicializar(balls, N_particles, size);
         .          .          .                   .          .          .                   .          .          .               //grid entropy
         .          .          .                   .          .          .                   .          .          .               std::unordered_map<int,int> grid_counts;
     2,003 ( 0.00%) 2 ( 0.00%) 2 ( 0.08%)        400 ( 0.00%) 0          0                 400 ( 0.00%) 0          0               for (auto ball : balls){
     5,600 ( 0.00%) 0          0               1,600 ( 0.00%) 0          0               1,600 ( 0.00%) 0          0                   counts(grid_counts, ball.getX(), ball.getY(), x_min, x_max, y_min, y_max, divisions);
         .          .          .                   .          .          .                   .          .          .               }
         4 ( 0.00%) 0          0                   1 ( 0.00%) 0          0                   2 ( 0.00%) 0          0               double entropy = compute_entropy(grid_counts, N_particles);
         .          .          .                   .          .          .                   .          .          .              
         .          .          .                   .          .          .                   .          .          .               int coin;
18,000,004 ( 0.08%) 0          0           6,000,001 ( 0.10%) 0          0                   0          0          0               for (int i = 0; i < t_final; i++)
         .          .          .                   .          .          .                   .          .          .               {
         .          .          .                   .          .          .                   .          .          .                   
30,000,000 ( 0.13%) 1 ( 0.00%) 1 ( 0.04%)  6,000,000 ( 0.10%) 0          0           6,000,000 ( 0.17%) 0          0                   coin = getRandomInt(N_particles-1, gen); //Selecciona que particula se movera
         .          .          .                   .          .          .                   .          .          .                   // %%%%%%%%%%%%% Posicion antigua %%%%%%%%%%%%%
18,000,000 ( 0.08%) 0          0                   0          0          0          12,000,000 ( 0.34%) 0          0                   double old_x = balls[coin].getX();
12,000,000 ( 0.05%) 0          0                   0          0          0          12,000,000 ( 0.34%) 0          0                   double old_y = balls[coin].getY();
42,000,000 ( 0.18%) 1 ( 0.00%) 1 ( 0.04%) 18,000,000 ( 0.31%) 1 ( 0.00%) 0           6,000,000 ( 0.17%) 0          0                   balls[coin].moveRandom(1, x_min, x_max, y_min, y_max, gen);        
         .          .          .                   .          .          .                   .          .          .                   
         .          .          .                   .          .          .                   .          .          .                   // %%%%%%%%%%%%% Posicion actual %%%%%%%%%%%%%
12,000,000 ( 0.05%) 0          0                   0          0          0           6,000,000 ( 0.17%) 0          0                   double new_x = balls[coin].getX();
12,000,000 ( 0.05%) 0          0                   0          0          0           6,000,000 ( 0.17%) 0          0                   double new_y = balls[coin].getY();
         .          .          .                   .          .          .                   .          .          .                   
         .          .          .                   .          .          .                   .          .          .                   // %%%%%%%%%%%%% Calcula el cambio en la entropia (2 casos) %%%%%%%%%%%%%
66,000,000 ( 0.28%) 1 ( 0.00%) 1 ( 0.04%) 36,000,000 ( 0.62%) 0          0           6,000,000 ( 0.17%) 0          0                   double ds = delta_entropy(grid_counts, new_x, new_y, x_min, x_max, y_min, y_max, divisions, old_x, old_y, N_particles);
12,000,000 ( 0.05%) 0          0           6,000,000 ( 0.10%) 0          0           6,000,000 ( 0.17%) 0          0                   entropy += ds;
         .          .          .                   .          .          .                   .          .          .           
24,000,000 ( 0.10%) 1 ( 0.00%) 1 ( 0.04%)          0          0          0           6,000,000 ( 0.17%) 0          0                   std::cout<<i<<"\t"<<entropy<<std::endl;
         .          .          .                   .          .          .                   .          .          .                  
         .          .          .                   .          .          .                   .          .          .                   
         .          .          .                   .          .          .                   .          .          .               }
         .          .          .                   .          .          .                   .          .          .               return 0;
        15 ( 0.00%) 1 ( 0.00%) 1 ( 0.04%)         10 ( 0.00%) 1 ( 0.00%) 0                   1 ( 0.00%) 0          0           }
--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/stl_algobase.h
--------------------------------------------------------------------------------
Ir                  I1mr       ILmr       Dr                  D1mr       DLmr       Dw                  D1mw       DLmw       

-- line 423 ----------------------------------------
         .          .          .                   .          .          .                   .          .          .           	  using __assignable = conditional<_IsMove,
         .          .          .                   .          .          .                   .          .          .           					   is_move_assignable<_Tp>,
         .          .          .                   .          .          .                   .          .          .           					   is_copy_assignable<_Tp>>;
         .          .          .                   .          .          .                   .          .          .           	  // trivial types can have deleted assignment
         .          .          .                   .          .          .                   .          .          .           	  static_assert( __assignable::type::value, "type is not assignable" );
         .          .          .                   .          .          .                   .          .          .           #endif
         .          .          .                   .          .          .                   .          .          .           	  const ptrdiff_t _Num = __last - __first;
         .          .          .                   .          .          .                   .          .          .           	  if (_Num)
24,000,000 ( 0.10%) 0          0          12,000,000 ( 0.21%) 0          0          12,000,000 ( 0.34%) 0          0           	    __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
         .          .          .                   .          .          .                   .          .          .           	  return __result + _Num;
         .          .          .                   .          .          .                   .          .          .           	}
         .          .          .                   .          .          .                   .          .          .               };
         .          .          .                   .          .          .                   .          .          .           
         .          .          .                   .          .          .                   .          .          .           _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
         .          .          .                   .          .          .                   .          .          .           
         .          .          .                   .          .          .                   .          .          .             template<typename _Tp, typename _Ref, typename _Ptr>
         .          .          .                   .          .          .                   .          .          .               struct _Deque_iterator;
-- line 439 ----------------------------------------

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  ./io/../sysdeps/unix/sysv/linux/write.c
  ./libio/./libio/fileops.c
  ./libio/./libio/genops.c
  ./libio/./libio/iofflush.c
  ./libio/./libio/iofwrite.c
  ./libio/./libio/libioP.h
  ./libio/./libio/putc.c
  ./libio/./libio/strops.c
  ./libio/./libio/vsnprintf.c
  ./locale/./locale/uselocale.c
  ./malloc/./malloc/malloc.c
  ./math/../sysdeps/ieee754/dbl-64/e_log.c
  ./nptl/./nptl/alloca_cutoff.c
  ./nptl/./nptl/pthread_once.c
  ./stdio-common/../include/rounding-mode.h
  ./stdio-common/../libio/libioP.h
  ./stdio-common/../sysdeps/generic/get-rounding-mode.h
  ./stdio-common/../sysdeps/pthread/allocalim.h
  ./stdio-common/./stdio-common/printf-parse.h
  ./stdio-common/./stdio-common/printf_fp.c
  ./stdio-common/./stdio-common/vfprintf-internal.c
  ./stdlib/../sysdeps/ieee754/dbl-64/dbl2mpn.c
  ./stdlib/../sysdeps/x86_64/lshift.S
  ./stdlib/../sysdeps/x86_64/mul_1.S
  ./string/../sysdeps/x86_64/multiarch/memchr-avx2.S
  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
  ./string/../sysdeps/x86_64/multiarch/strchr-avx2.S
  ./string/../sysdeps/x86_64/multiarch/strlen-avx2.S

--------------------------------------------------------------------------------
Ir                     I1mr                ILmr        Dr                   D1mr             DLmr       Dw                   D1mw         DLmw        
--------------------------------------------------------------------------------
2,549,451,109 (10.82%) 18,000,075 ( 8.57%) 64 ( 2.56%) 565,487,462 ( 9.75%) 170,725 (75.91%) 1 ( 0.01%) 401,355,625 (11.41%) 158 ( 5.51%) 99 ( 5.29%)  events annotated

