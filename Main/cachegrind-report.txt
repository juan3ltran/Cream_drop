--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         8388608 B, 64 B, direct-mapped
Command:          ./main.x
Data file:        cachegrind.out.12056
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                     I1mr           ILmr           Dr                   D1mr            DLmr           Dw                   D1mw           DLmw           
--------------------------------------------------------------------------------
3,473,526,407 (100.0%) 2,657 (100.0%) 2,471 (100.0%) 829,724,152 (100.0%) 14,219 (100.0%) 7,844 (100.0%) 505,591,913 (100.0%) 2,844 (100.0%) 1,844 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                   I1mr         ILmr         Dr                   D1mr           DLmr           Dw                  D1mw           DLmw          file:function
--------------------------------------------------------------------------------
384,006,427 (11.06%)  15 ( 0.56%)  14 ( 0.57%) 120,001,846 (14.46%)    10 ( 0.07%)     1 ( 0.01%) 66,000,822 (13.05%)     0            0           ./malloc/./malloc/malloc.c:_int_free
378,430,694 (10.89%)   6 ( 0.23%)   6 ( 0.24%)  84,121,111 (10.14%)     0              0          84,000,000 (16.61%)     0            0           /home/juanb3ltran/Documentos/Universidad/Alto_rendimiento/Cream_drop/Main/utils.cpp:Particle::moveRandom(double, double, double, double, double, std::mersenne_twister_engine<unsigned long, 32ul, 624ul, 397ul, 31ul, 2567483615ul, 11ul, 4294967295ul, 7ul, 2636928640ul, 15ul, 4022730752ul, 18ul, 1812433253ul>&)
373,858,698 (10.76%)   2 ( 0.08%)   2 ( 0.08%)  84,419,706 (10.17%)     0              0          72,359,748 (14.31%)     0            0           /usr/include/c++/11/bits/uniform_int_dist.h:int std::uniform_int_distribution<int>::operator()<std::mersenne_twister_engine<unsigned long, 32ul, 624ul, 397ul, 31ul, 2567483615ul, 11ul, 4294967295ul, 7ul, 2636928640ul, 15ul, 4022730752ul, 18ul, 1812433253ul> >(std::mersenne_twister_engine<unsigned long, 32ul, 624ul, 397ul, 31ul, 2567483615ul, 11ul, 4294967295ul, 7ul, 2636928640ul, 15ul, 4022730752ul, 18ul, 1812433253ul>&, std::uniform_int_distribution<int>::param_type const&) [clone .isra.0]
318,955,148 ( 9.18%)   8 ( 0.30%)   8 ( 0.32%)  67,210,925 ( 8.10%)     0              0          48,347,382 ( 9.56%)     0            0           /home/juanb3ltran/Documentos/Universidad/Alto_rendimiento/Cream_drop/Main/utils.cpp:delta_entropy(std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<int const, int> > >&, double, double, double, double, double, double, int, double, double, int)
280,242,238 ( 8.07%)   4 ( 0.15%)   4 ( 0.16%)  36,236,636 ( 4.37%)     4 ( 0.03%)     0          18,089,375 ( 3.58%)     0            0           /usr/include/c++/11/bits/random.tcc:std::mersenne_twister_engine<unsigned long, 32ul, 624ul, 397ul, 31ul, 2567483615ul, 11ul, 4294967295ul, 7ul, 2636928640ul, 15ul, 4022730752ul, 18ul, 1812433253ul>::_M_gen_rand()
258,003,593 ( 7.43%)  13 ( 0.49%)   7 ( 0.28%)  66,000,898 ( 7.95%)     7 ( 0.05%)     1 ( 0.01%) 36,000,331 ( 7.12%)     0            0           ./malloc/./malloc/malloc.c:malloc
253,310,871 ( 7.29%)   4 ( 0.15%)   4 ( 0.16%)  24,137,167 ( 2.91%)     0              0          12,077,209 ( 2.39%)     0            0           /usr/include/c++/11/bits/random.tcc:int std::uniform_int_distribution<int>::operator()<std::mersenne_twister_engine<unsigned long, 32ul, 624ul, 397ul, 31ul, 2567483615ul, 11ul, 4294967295ul, 7ul, 2636928640ul, 15ul, 4022730752ul, 18ul, 1812433253ul> >(std::mersenne_twister_engine<unsigned long, 32ul, 624ul, 397ul, 31ul, 2567483615ul, 11ul, 4294967295ul, 7ul, 2636928640ul, 15ul, 4022730752ul, 18ul, 1812433253ul>&, std::uniform_int_distribution<int>::param_type const&) [clone .isra.0]
228,007,683 ( 6.56%)  14 ( 0.53%)  13 ( 0.53%)  66,002,017 ( 7.95%)     3 ( 0.02%)     1 ( 0.01%) 54,002,021 (10.68%)     1 ( 0.04%)   0           /home/juanb3ltran/Documentos/Universidad/Alto_rendimiento/Cream_drop/Main/main.cpp:main
132,001,738 ( 3.80%)   5 ( 0.19%)   3 ( 0.12%)  48,000,632 ( 5.79%)     5 ( 0.04%)     0          24,000,316 ( 4.75%)     0            0           ./malloc/./malloc/malloc.c:free
126,046,768 ( 3.63%)   4 ( 0.15%)   4 ( 0.16%)  12,011,692 ( 1.45%)     0              0           6,011,692 ( 1.19%)     0            0           /usr/include/c++/11/bits/random.tcc:getRandomInt(int, std::mersenne_twister_engine<unsigned long, 32ul, 624ul, 397ul, 31ul, 2567483615ul, 11ul, 4294967295ul, 7ul, 2636928640ul, 15ul, 4022730752ul, 18ul, 1812433253ul>&, bool)
 96,000,000 ( 2.76%)   2 ( 0.08%)   2 ( 0.08%)  36,000,000 ( 4.34%)     0              0          30,000,000 ( 5.93%)     0            0           /home/juanb3ltran/Documentos/Universidad/Alto_rendimiento/Cream_drop/Main/utils.cpp:getRandomInt(int, std::mersenne_twister_engine<unsigned long, 32ul, 624ul, 397ul, 31ul, 2567483615ul, 11ul, 4294967295ul, 7ul, 2636928640ul, 15ul, 4022730752ul, 18ul, 1812433253ul>&, bool)
 72,000,948 ( 2.07%)   2 ( 0.08%)   2 ( 0.08%)  12,000,158 ( 1.45%)     0              0          12,000,158 ( 2.37%)     0            0           ???:operator new(unsigned long)
 66,000,009 ( 1.90%)   0            0           30,000,002 ( 3.62%)     0              0                   2 ( 0.00%)     0            0           /usr/include/c++/11/bits/stl_vector.h:main
 64,615,702 ( 1.86%) 339 (12.76%) 299 (12.10%)  32,307,544 ( 3.89%)   194 ( 1.36%)    10 ( 0.13%)        562 ( 0.00%)    22 ( 0.77%)  13 ( 0.70%)  ???:???
 60,000,000 ( 1.73%)   0            0                    0              0              0                   0              0            0           /usr/include/c++/11/bits/uniform_int_dist.h:getRandomInt(int, std::mersenne_twister_engine<unsigned long, 32ul, 624ul, 397ul, 31ul, 2567483615ul, 11ul, 4294967295ul, 7ul, 2636928640ul, 15ul, 4022730752ul, 18ul, 1812433253ul>&, bool)
 54,269,811 ( 1.56%)   0            0                    0              0              0          12,059,958 ( 2.39%)     0            0           /usr/include/c++/11/bits/uniform_int_dist.h:Particle::moveRandom(double, double, double, double, double, std::mersenne_twister_engine<unsigned long, 32ul, 624ul, 397ul, 31ul, 2567483615ul, 11ul, 4294967295ul, 7ul, 2636928640ul, 15ul, 4022730752ul, 18ul, 1812433253ul>&)
 54,000,000 ( 1.55%)   0            0           12,000,000 ( 1.45%)     0              0           6,000,000 ( 1.19%)     0            0           /usr/include/c++/11/ext/new_allocator.h:Particle::moveRandom(double, double, double, double, double, std::mersenne_twister_engine<unsigned long, 32ul, 624ul, 397ul, 31ul, 2567483615ul, 11ul, 4294967295ul, 7ul, 2636928640ul, 15ul, 4022730752ul, 18ul, 1812433253ul>&)
 53,016,288 ( 1.53%)   5 ( 0.19%)   5 ( 0.20%)  12,677,808 ( 1.53%)    36 ( 0.25%)    36 ( 0.46%)          0              0            0           ./math/../sysdeps/ieee754/dbl-64/e_log.c:__ieee754_log_fma
 50,299,980 ( 1.45%)   3 ( 0.11%)   3 ( 0.12%)  17,343,857 ( 2.09%)     0              0          10,405,780 ( 2.06%)     0            0           /usr/include/c++/11/bits/hashtable_policy.h:std::__detail::_Map_base<int, std::pair<int const, int>, std::allocator<std::pair<int const, int> >, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>, true>::operator[](int&&)
 36,001,200 ( 1.04%)   1 ( 0.04%)   1 ( 0.04%)  24,000,800 ( 2.89%)     0              0                   0              0            0           /home/juanb3ltran/Documentos/Universidad/Alto_rendimiento/Cream_drop/Main/utils.cpp:Particle::getY() const
 36,001,200 ( 1.04%)   0            0           24,000,800 ( 2.89%)     0              0                   0              0            0           /home/juanb3ltran/Documentos/Universidad/Alto_rendimiento/Cream_drop/Main/utils.cpp:Particle::getX() const
 24,000,000 ( 0.69%)   0            0           12,000,000 ( 1.45%)     0              0          12,000,000 ( 2.37%)     0            0           /usr/include/c++/11/bits/stl_algobase.h:Particle::moveRandom(double, double, double, double, double, std::mersenne_twister_engine<unsigned long, 32ul, 624ul, 397ul, 31ul, 2567483615ul, 11ul, 4294967295ul, 7ul, 2636928640ul, 15ul, 4022730752ul, 18ul, 1812433253ul>&)
 18,000,237 ( 0.52%)   0            0                    0              0              0                   0              0            0           ./malloc/./malloc/arena.c:free
 15,614,745 ( 0.45%)   1 ( 0.04%)   1 ( 0.04%)   6,938,484 ( 0.84%)     0              0                 371 ( 0.00%)     0            0           /usr/include/c++/11/bits/hashtable.h:std::__detail::_Map_base<int, std::pair<int const, int>, std::allocator<std::pair<int const, int> >, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>, true>::operator[](int&&)
 12,000,158 ( 0.35%)   1 ( 0.04%)   1 ( 0.04%)           0              0              0                   0              0            0           ???:operator delete(void*)
 12,000,156 ( 0.35%)   0            0                    0              0              0                   0              0            0           ???:operator delete(void*, unsigned long)
  5,779,620 ( 0.17%)   2 ( 0.08%)   2 ( 0.08%)           0              0              0           2,022,867 ( 0.40%)     0            0           /usr/include/c++/11/bits/unordered_map.h:delta_entropy(std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<int const, int> > >&, double, double, double, double, double, double, int, double, double, int)
  5,762,640 ( 0.17%)   2 ( 0.08%)   2 ( 0.08%)           0              0              0                   0              0            0           ./math/./w_log_template.c:log@@GLIBC_2.29

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/ext/new_allocator.h
--------------------------------------------------------------------------------
Ir                  I1mr       ILmr       Dr                  D1mr       DLmr       Dw                 D1mw       DLmw       

-- line 103 ----------------------------------------
         .          .          .                   .          .          .                  .          .          .                 allocate(size_type __n, const void* = static_cast<const void*>(0))
         .          .          .                   .          .          .                  .          .          .                 {
         .          .          .                   .          .          .                  .          .          .           #if __cplusplus >= 201103L
         .          .          .                   .          .          .                  .          .          .           	 // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .          .          .                   .          .          .                  .          .          .           	 // 3308. std::allocator<void>().allocate(n)
         .          .          .                   .          .          .                  .          .          .           	 static_assert(sizeof(_Tp) != 0, "cannot allocate incomplete types");
         .          .          .                   .          .          .                  .          .          .           #endif
         .          .          .                   .          .          .                  .          .          .           
        16 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)          0          0          0                  0          0          0           	if (__builtin_expect(__n > this->_M_max_size(), false))
         .          .          .                   .          .          .                  .          .          .           	  {
         .          .          .                   .          .          .                  .          .          .           	    // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .          .          .                   .          .          .                  .          .          .           	    // 3190. allocator::allocate sometimes returns too little storage
         .          .          .                   .          .          .                  .          .          .           	    if (__n > (std::size_t(-1) / sizeof(_Tp)))
         .          .          .                   .          .          .                  .          .          .           	      std::__throw_bad_array_new_length();
         .          .          .                   .          .          .                  .          .          .           	    std::__throw_bad_alloc();
         .          .          .                   .          .          .                  .          .          .           	  }
         .          .          .                   .          .          .                  .          .          .           
         .          .          .                   .          .          .                  .          .          .           #if __cpp_aligned_new
         .          .          .                   .          .          .                  .          .          .           	if (alignof(_Tp) > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
         .          .          .                   .          .          .                  .          .          .           	  {
         .          .          .                   .          .          .                  .          .          .           	    std::align_val_t __al = std::align_val_t(alignof(_Tp));
         .          .          .                   .          .          .                  .          .          .           	    return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), __al));
         .          .          .                   .          .          .                  .          .          .           	  }
         .          .          .                   .          .          .                  .          .          .           #endif
18,000,338 ( 0.52%) 3 ( 0.11%) 3 ( 0.12%)         20 ( 0.00%) 0          0          6,000,108 ( 1.19%) 0          0           	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
         .          .          .                   .          .          .                  .          .          .                 }
         .          .          .                   .          .          .                  .          .          .           
         .          .          .                   .          .          .                  .          .          .                 // __p is not permitted to be a null pointer.
         .          .          .                   .          .          .                  .          .          .                 void
         9 ( 0.00%) 0          0                   0          0          0                  9 ( 0.00%) 0          0                 deallocate(_Tp* __p, size_type __t __attribute__ ((__unused__)))
         .          .          .                   .          .          .                  .          .          .                 {
         .          .          .                   .          .          .                  .          .          .           #if __cpp_aligned_new
         .          .          .                   .          .          .                  .          .          .           	if (alignof(_Tp) > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
         .          .          .                   .          .          .                  .          .          .           	  {
         .          .          .                   .          .          .                  .          .          .           	    ::operator delete(__p,
         .          .          .                   .          .          .                  .          .          .           # if __cpp_sized_deallocation
         .          .          .                   .          .          .                  .          .          .           			      __t * sizeof(_Tp),
         .          .          .                   .          .          .                  .          .          .           # endif
         .          .          .                   .          .          .                  .          .          .           			      std::align_val_t(alignof(_Tp)));
         .          .          .                   .          .          .                  .          .          .           	    return;
         .          .          .                   .          .          .                  .          .          .           	  }
         .          .          .                   .          .          .                  .          .          .           #endif
36,000,191 ( 1.04%) 0          0          12,000,018 ( 1.45%) 0          0                 86 ( 0.00%) 0          0           	::operator delete(__p
         .          .          .                   .          .          .                  .          .          .           #if __cpp_sized_deallocation
         .          .          .                   .          .          .                  .          .          .           			  , __t * sizeof(_Tp)
         .          .          .                   .          .          .                  .          .          .           #endif
         .          .          .                   .          .          .                  .          .          .           			 );
         .          .          .                   .          .          .                  .          .          .                 }
         .          .          .                   .          .          .                  .          .          .           
         .          .          .                   .          .          .                  .          .          .           #if __cplusplus <= 201703L
         .          .          .                   .          .          .                  .          .          .                 size_type
         .          .          .                   .          .          .                  .          .          .                 max_size() const _GLIBCXX_USE_NOEXCEPT
         .          .          .                   .          .          .                  .          .          .                 { return _M_max_size(); }
         .          .          .                   .          .          .                  .          .          .           
         .          .          .                   .          .          .                  .          .          .           #if __cplusplus >= 201103L
         .          .          .                   .          .          .                  .          .          .                 template<typename _Up, typename... _Args>
         .          .          .                   .          .          .                  .          .          .           	void
       511 ( 0.00%) 0          0                 511 ( 0.00%) 0          0                  0          0          0           	construct(_Up* __p, _Args&&... __args)
         .          .          .                   .          .          .                  .          .          .           	noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)
         .          .          .                   .          .          .                  .          .          .           	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
         .          .          .                   .          .          .                  .          .          .           
         .          .          .                   .          .          .                  .          .          .                 template<typename _Up>
         .          .          .                   .          .          .                  .          .          .           	void
         .          .          .                   .          .          .                  .          .          .           	destroy(_Up* __p)
         .          .          .                   .          .          .                  .          .          .           	noexcept(std::is_nothrow_destructible<_Up>::value)
         .          .          .                   .          .          .                  .          .          .           	{ __p->~_Up(); }
-- line 168 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/stl_algobase.h
--------------------------------------------------------------------------------
Ir                  I1mr       ILmr       Dr                  D1mr       DLmr       Dw                  D1mw       DLmw       

-- line 423 ----------------------------------------
         .          .          .                   .          .          .                   .          .          .           	  using __assignable = conditional<_IsMove,
         .          .          .                   .          .          .                   .          .          .           					   is_move_assignable<_Tp>,
         .          .          .                   .          .          .                   .          .          .           					   is_copy_assignable<_Tp>>;
         .          .          .                   .          .          .                   .          .          .           	  // trivial types can have deleted assignment
         .          .          .                   .          .          .                   .          .          .           	  static_assert( __assignable::type::value, "type is not assignable" );
         .          .          .                   .          .          .                   .          .          .           #endif
         .          .          .                   .          .          .                   .          .          .           	  const ptrdiff_t _Num = __last - __first;
         .          .          .                   .          .          .                   .          .          .           	  if (_Num)
24,000,000 ( 0.69%) 0          0          12,000,000 ( 1.45%) 0          0          12,000,000 ( 2.37%) 0          0           	    __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
         .          .          .                   .          .          .                   .          .          .           	  return __result + _Num;
         .          .          .                   .          .          .                   .          .          .           	}
         .          .          .                   .          .          .                   .          .          .               };
         .          .          .                   .          .          .                   .          .          .           
         .          .          .                   .          .          .                   .          .          .           _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
         .          .          .                   .          .          .                   .          .          .           
         .          .          .                   .          .          .                   .          .          .             template<typename _Tp, typename _Ref, typename _Ptr>
         .          .          .                   .          .          .                   .          .          .               struct _Deque_iterator;
-- line 439 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/hashtable_policy.h
--------------------------------------------------------------------------------
Ir                  I1mr       ILmr       Dr                  D1mr        DLmr       Dw                  D1mw       DLmw       

-- line 211 ----------------------------------------
         .          .          .                   .           .          .                   .          .          .              *  template parameter of class template _Hashtable controls whether
         .          .          .                   .           .          .                   .          .          .              *  nodes also store a hash code. In some cases (e.g. strings) this
         .          .          .                   .           .          .                   .          .          .              *  may be a performance win.
         .          .          .                   .           .          .                   .          .          .              */
         .          .          .                   .           .          .                   .          .          .             struct _Hash_node_base
         .          .          .                   .           .          .                   .          .          .             {
         .          .          .                   .           .          .                   .          .          .               _Hash_node_base* _M_nxt;
         .          .          .                   .           .          .                   .          .          .           
        65 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)          0           0          0                  65 ( 0.00%) 0          0               _Hash_node_base() noexcept : _M_nxt() { }
         .          .          .                   .           .          .                   .          .          .           
         .          .          .                   .           .          .                   .          .          .               _Hash_node_base(_Hash_node_base* __next) noexcept : _M_nxt(__next) { }
         .          .          .                   .           .          .                   .          .          .             };
         .          .          .                   .           .          .                   .          .          .           
         .          .          .                   .           .          .                   .          .          .             /**
         .          .          .                   .           .          .                   .          .          .              *  struct _Hash_node_value_base
         .          .          .                   .           .          .                   .          .          .              *
         .          .          .                   .           .          .                   .          .          .              *  Node type with the value to store.
-- line 227 ----------------------------------------
-- line 274 ----------------------------------------
         .          .          .                   .           .          .                   .          .          .              *  Primary template struct _Hash_node.
         .          .          .                   .           .          .                   .          .          .              */
         .          .          .                   .           .          .                   .          .          .             template<typename _Value, bool _Cache_hash_code>
         .          .          .                   .           .          .                   .          .          .               struct _Hash_node
         .          .          .                   .           .          .                   .          .          .               : _Hash_node_base
         .          .          .                   .           .          .                   .          .          .               , _Hash_node_value<_Value, _Cache_hash_code>
         .          .          .                   .           .          .                   .          .          .               {
         .          .          .                   .           .          .                   .          .          .                 _Hash_node*
       165 ( 0.00%) 0          0                   0           0          0                   0          0          0                 _M_next() const noexcept
       169 ( 0.00%) 0          0                 169 ( 0.00%) 13 ( 0.09%) 0                   0          0          0                 { return static_cast<_Hash_node*>(this->_M_nxt); }
         .          .          .                   .           .          .                   .          .          .               };
         .          .          .                   .           .          .                   .          .          .           
         .          .          .                   .           .          .                   .          .          .             /// Base class for node iterators.
         .          .          .                   .           .          .                   .          .          .             template<typename _Value, bool _Cache_hash_code>
         .          .          .                   .           .          .                   .          .          .               struct _Node_iterator_base
         .          .          .                   .           .          .                   .          .          .               {
         .          .          .                   .           .          .                   .          .          .                 using __node_type = _Hash_node<_Value, _Cache_hash_code>;
         .          .          .                   .           .          .                   .          .          .           
-- line 291 ----------------------------------------
-- line 422 ----------------------------------------
         .          .          .                   .           .          .                   .          .          .             {
         .          .          .                   .           .          .                   .          .          .               typedef std::size_t first_argument_type;
         .          .          .                   .           .          .                   .          .          .               typedef std::size_t second_argument_type;
         .          .          .                   .           .          .                   .          .          .               typedef std::size_t result_type;
         .          .          .                   .           .          .                   .          .          .           
         .          .          .                   .           .          .                   .          .          .               result_type
         .          .          .                   .           .          .                   .          .          .               operator()(first_argument_type __num,
         .          .          .                   .           .          .                   .          .          .           	       second_argument_type __den) const noexcept
 5,205,058 ( 0.15%) 1 ( 0.04%) 1 ( 0.04%)         59 ( 0.00%)  0          0                   0          0          0               { return __num % __den; }
         .          .          .                   .           .          .                   .          .          .             };
         .          .          .                   .           .          .                   .          .          .           
         .          .          .                   .           .          .                   .          .          .             /// Default ranged hash function H.  In principle it should be a
         .          .          .                   .           .          .                   .          .          .             /// function object composed from objects of type H1 and H2 such that
         .          .          .                   .           .          .                   .          .          .             /// h(k, N) = h2(h1(k), N), but that would mean making extra copies of
         .          .          .                   .           .          .                   .          .          .             /// h1 and h2.  So instead we'll just use a tag to tell class template
         .          .          .                   .           .          .                   .          .          .             /// hashtable to do that composition.
         .          .          .                   .           .          .                   .          .          .             struct _Default_ranged_hash { };
-- line 438 ----------------------------------------
-- line 439 ----------------------------------------
         .          .          .                   .           .          .                   .          .          .           
         .          .          .                   .           .          .                   .          .          .             /// Default value for rehash policy.  Bucket size is (usually) the
         .          .          .                   .           .          .                   .          .          .             /// smallest prime that keeps the load factor small enough.
         .          .          .                   .           .          .                   .          .          .             struct _Prime_rehash_policy
         .          .          .                   .           .          .                   .          .          .             {
         .          .          .                   .           .          .                   .          .          .               using __has_load_factor = true_type;
         .          .          .                   .           .          .                   .          .          .           
         .          .          .                   .           .          .                   .          .          .               _Prime_rehash_policy(float __z = 1.0) noexcept
         2 ( 0.00%) 0          0                   0           0          0                   2 ( 0.00%) 0          0               : _M_max_load_factor(__z), _M_next_resize(0) { }
         .          .          .                   .           .          .                   .          .          .           
         .          .          .                   .           .          .                   .          .          .               float
         .          .          .                   .           .          .                   .          .          .               max_load_factor() const noexcept
         .          .          .                   .           .          .                   .          .          .               { return _M_max_load_factor; }
         .          .          .                   .           .          .                   .          .          .           
         .          .          .                   .           .          .                   .          .          .               // Return a bucket size no smaller than n.
         .          .          .                   .           .          .                   .          .          .               std::size_t
         .          .          .                   .           .          .                   .          .          .               _M_next_bkt(std::size_t __n) const;
-- line 455 ----------------------------------------
-- line 715 ----------------------------------------
         .          .          .                   .           .          .                   .          .          .                 __node._M_node = nullptr;
         .          .          .                   .           .          .                   .          .          .                 return __pos->second;
         .          .          .                   .           .          .                   .          .          .               }
         .          .          .                   .           .          .                   .          .          .           
         .          .          .                   .           .          .                   .          .          .             template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
         .          .          .                   .           .          .                   .          .          .           	   typename _Hash, typename _RangeHash, typename _Unused,
         .          .          .                   .           .          .                   .          .          .           	   typename _RehashPolicy, typename _Traits>
         .          .          .                   .           .          .                   .          .          .               auto
20,811,432 ( 0.60%) 2 ( 0.08%) 2 ( 0.08%)  1,734,286 ( 0.21%)  0          0          10,405,716 ( 2.06%) 0          0               _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
         .          .          .                   .           .          .                   .          .          .           	      _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>::
         .          .          .                   .           .          .                   .          .          .               operator[](key_type&& __k)
         .          .          .                   .           .          .                   .          .          .               -> mapped_type&
         .          .          .                   .           .          .                   .          .          .               {
         .          .          .                   .           .          .                   .          .          .                 __hashtable* __h = static_cast<__hashtable*>(this);
         .          .          .                   .           .          .                   .          .          .                 __hash_code __code = __h->_M_hash_code(__k);
         .          .          .                   .           .          .                   .          .          .                 std::size_t __bkt = __h->_M_bucket_index(__code);
         .          .          .                   .           .          .                   .          .          .                 if (auto __node = __h->_M_find_node(__bkt, __k, __code))
 1,734,222 ( 0.05%) 0          0                   0           0          0                   0          0          0           	return __node->_M_v().second;
         .          .          .                   .           .          .                   .          .          .           
         .          .          .                   .           .          .                   .          .          .                 typename __hashtable::_Scoped_node __node {
         .          .          .                   .           .          .                   .          .          .           	__h,
         .          .          .                   .           .          .                   .          .          .           	std::piecewise_construct,
         .          .          .                   .           .          .                   .          .          .           	std::forward_as_tuple(std::move(__k)),
         .          .          .                   .           .          .                   .          .          .           	std::tuple<>()
         .          .          .                   .           .          .                   .          .          .                 };
         .          .          .                   .           .          .                   .          .          .                 auto __pos
         .          .          .                   .           .          .                   .          .          .           	= __h->_M_insert_unique_node(__bkt, __code, __node._M_node);
         .          .          .                   .           .          .                   .          .          .                 __node._M_node = nullptr;
        64 ( 0.00%) 0          0                   0           0          0                   0          0          0                 return __pos->second;
17,342,860 ( 0.50%) 0          0          13,874,288 ( 1.67%)  0          0                   0          0          0               }
         .          .          .                   .           .          .                   .          .          .           
         .          .          .                   .           .          .                   .          .          .             template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
         .          .          .                   .           .          .                   .          .          .           	   typename _Hash, typename _RangeHash, typename _Unused,
         .          .          .                   .           .          .                   .          .          .           	   typename _RehashPolicy, typename _Traits>
         .          .          .                   .           .          .                   .          .          .               auto
         .          .          .                   .           .          .                   .          .          .               _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
         .          .          .                   .           .          .                   .          .          .           	      _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>::
         .          .          .                   .           .          .                   .          .          .               at(const key_type& __k)
-- line 752 ----------------------------------------
-- line 1211 ----------------------------------------
         .          .          .                   .           .          .                   .          .          .           
         .          .          .                   .           .          .                   .          .          .                 _Hash_code_base(const _Hash& __hash) : __ebo_hash(__hash) { }
         .          .          .                   .           .          .                   .          .          .           
         .          .          .                   .           .          .                   .          .          .                 __hash_code
         .          .          .                   .           .          .                   .          .          .                 _M_hash_code(const _Key& __k) const
         .          .          .                   .           .          .                   .          .          .                 {
         .          .          .                   .           .          .                   .          .          .           	static_assert(__is_invocable<const _Hash&, const _Key&>{},
         .          .          .                   .           .          .                   .          .          .           	    "hash function must be invocable with an argument of key type");
 1,736,162 ( 0.05%) 0          0           1,735,224 ( 0.21%)  0          0                   0          0          0           	return _M_hash()(__k);
         .          .          .                   .           .          .                   .          .          .                 }
         .          .          .                   .           .          .                   .          .          .           
         .          .          .                   .           .          .                   .          .          .                 template<typename _Kt>
         .          .          .                   .           .          .                   .          .          .           	__hash_code
         .          .          .                   .           .          .                   .          .          .           	_M_hash_code_tr(const _Kt& __k) const
         .          .          .                   .           .          .                   .          .          .           	{
         .          .          .                   .           .          .                   .          .          .           	  static_assert(__is_invocable<const _Hash&, const _Kt&>{},
         .          .          .                   .           .          .                   .          .          .           	    "hash function must be invocable with an argument of key type");
-- line 1227 ----------------------------------------
-- line 1609 ----------------------------------------
         .          .          .                   .           .          .                   .          .          .           
         .          .          .                   .           .          .                   .          .          .                 bool
         .          .          .                   .           .          .                   .          .          .                 _M_equals(const _Key& __k, __hash_code __c,
         .          .          .                   .           .          .                   .          .          .           		const _Hash_node_value<_Value, __hash_cached::value>& __n) const
         .          .          .                   .           .          .                   .          .          .                 {
         .          .          .                   .           .          .                   .          .          .           	static_assert(__is_invocable<const _Equal&, const _Key&, const _Key&>{},
         .          .          .                   .           .          .                   .          .          .           	  "key equality predicate must be invocable with two arguments of "
         .          .          .                   .           .          .                   .          .          .           	  "key type");
 3,470,320 ( 0.10%) 0          0                   0           0          0                   0          0          0           	return _S_equals(__c, __n) && _M_eq()(__k, _ExtractKey{}(__n._M_v()));
         .          .          .                   .           .          .                   .          .          .                 }
         .          .          .                   .           .          .                   .          .          .           
         .          .          .                   .           .          .                   .          .          .                 template<typename _Kt>
         .          .          .                   .           .          .                   .          .          .           	bool
         .          .          .                   .           .          .                   .          .          .           	_M_equals_tr(const _Kt& __k, __hash_code __c,
         .          .          .                   .           .          .                   .          .          .           		     const _Hash_node_value<_Value,
         .          .          .                   .           .          .                   .          .          .           					    __hash_cached::value>& __n) const
         .          .          .                   .           .          .                   .          .          .           	{
-- line 1625 ----------------------------------------
-- line 1904 ----------------------------------------
         .          .          .                   .           .          .                   .          .          .                 __n->~__node_type();
         .          .          .                   .           .          .                   .          .          .                 __node_alloc_traits::deallocate(_M_node_allocator(), __ptr, 1);
         .          .          .                   .           .          .                   .          .          .               }
         .          .          .                   .           .          .                   .          .          .           
         .          .          .                   .           .          .                   .          .          .             template<typename _NodeAlloc>
         .          .          .                   .           .          .                   .          .          .               void
         .          .          .                   .           .          .                   .          .          .               _Hashtable_alloc<_NodeAlloc>::_M_deallocate_nodes(__node_ptr __n)
         .          .          .                   .           .          .                   .          .          .               {
       131 ( 0.00%) 0          0                   0           0          0                   0          0          0                 while (__n)
         .          .          .                   .           .          .                   .          .          .           	{
         .          .          .                   .           .          .                   .          .          .           	  __node_ptr __tmp = __n;
         .          .          .                   .           .          .                   .          .          .           	  __n = __n->_M_next();
         .          .          .                   .           .          .                   .          .          .           	  _M_deallocate_node(__tmp);
         .          .          .                   .           .          .                   .          .          .           	}
         .          .          .                   .           .          .                   .          .          .               }
         .          .          .                   .           .          .                   .          .          .           
         .          .          .                   .           .          .                   .          .          .             template<typename _NodeAlloc>
-- line 1920 ----------------------------------------
-- line 1921 ----------------------------------------
         .          .          .                   .           .          .                   .          .          .               auto
         .          .          .                   .           .          .                   .          .          .               _Hashtable_alloc<_NodeAlloc>::_M_allocate_buckets(std::size_t __bkt_count)
         .          .          .                   .           .          .                   .          .          .               -> __buckets_ptr
         .          .          .                   .           .          .                   .          .          .               {
         .          .          .                   .           .          .                   .          .          .                 __buckets_alloc_type __alloc(_M_node_allocator());
         .          .          .                   .           .          .                   .          .          .           
         .          .          .                   .           .          .                   .          .          .                 auto __ptr = __buckets_alloc_traits::allocate(__alloc, __bkt_count);
         .          .          .                   .           .          .                   .          .          .                 __buckets_ptr __p = std::__to_address(__ptr);
        16 ( 0.00%) 0          0                   0           0          0                   4 ( 0.00%) 0          0                 __builtin_memset(__p, 0, __bkt_count * sizeof(__node_base_ptr));
         .          .          .                   .           .          .                   .          .          .                 return __p;
         .          .          .                   .           .          .                   .          .          .               }
         .          .          .                   .           .          .                   .          .          .           
         .          .          .                   .           .          .                   .          .          .             template<typename _NodeAlloc>
         .          .          .                   .           .          .                   .          .          .               void
         .          .          .                   .           .          .                   .          .          .               _Hashtable_alloc<_NodeAlloc>::
         .          .          .                   .           .          .                   .          .          .               _M_deallocate_buckets(__buckets_ptr __bkts,
         .          .          .                   .           .          .                   .          .          .           			  std::size_t __bkt_count)
-- line 1937 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/random.tcc
--------------------------------------------------------------------------------
Ir                  I1mr       ILmr       Dr                  D1mr       DLmr       Dw                  D1mw        DLmw       

-- line 319 ----------------------------------------
         .          .          .                   .          .          .                   .           .          .           	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
         .          .          .                   .          .          .                   .           .          .           	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
         .          .          .                   .          .          .                   .           .          .           	   _UIntType __f>
         .          .          .                   .          .          .                   .           .          .               void
         .          .          .                   .          .          .                   .           .          .               mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
         .          .          .                   .          .          .                   .           .          .           			    __s, __b, __t, __c, __l, __f>::
         .          .          .                   .          .          .                   .           .          .               seed(result_type __sd)
         .          .          .                   .          .          .                   .           .          .               {
         1 ( 0.00%) 0          0                   0          0          0                   1 ( 0.00%)  1 ( 0.04%) 0                 _M_x[0] = __detail::__mod<_UIntType,
         .          .          .                   .          .          .                   .           .          .           	__detail::_Shift<_UIntType, __w>::__value>(__sd);
         .          .          .                   .          .          .                   .           .          .           
     1,870 ( 0.00%) 0          0                   0          0          0                   0           0          0                 for (size_t __i = 1; __i < state_size; ++__i)
         .          .          .                   .          .          .                   .           .          .           	{
         .          .          .                   .          .          .                   .           .          .           	  _UIntType __x = _M_x[__i - 1];
     1,869 ( 0.00%) 0          0                   0          0          0                   0           0          0           	  __x ^= __x >> (__w - 2);
       623 ( 0.00%) 0          0                   0          0          0                   0           0          0           	  __x *= __f;
         .          .          .                   .          .          .                   .           .          .           	  __x += __detail::__mod<_UIntType, __n>(__i);
       623 ( 0.00%) 0          0                   0          0          0                 623 ( 0.00%) 57 ( 2.00%) 0           	  _M_x[__i] = __detail::__mod<_UIntType,
         .          .          .                   .          .          .                   .           .          .           	    __detail::_Shift<_UIntType, __w>::__value>(__x);
         .          .          .                   .          .          .                   .           .          .           	}
         1 ( 0.00%) 0          0                   0          0          0                   1 ( 0.00%)  0          0                 _M_p = state_size;
         .          .          .                   .          .          .                   .           .          .               }
         .          .          .                   .          .          .                   .           .          .           
         .          .          .                   .          .          .                   .           .          .             template<typename _UIntType,
         .          .          .                   .          .          .                   .           .          .           	   size_t __w, size_t __n, size_t __m, size_t __r,
         .          .          .                   .          .          .                   .           .          .           	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
         .          .          .                   .          .          .                   .           .          .           	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
         .          .          .                   .          .          .                   .           .          .           	   _UIntType __f>
         .          .          .                   .          .          .                   .           .          .               template<typename _Sseq>
-- line 347 ----------------------------------------
-- line 386 ----------------------------------------
         .          .          .                   .          .          .                   .           .          .                 }
         .          .          .                   .          .          .                   .           .          .           
         .          .          .                   .          .          .                   .           .          .             template<typename _UIntType, size_t __w,
         .          .          .                   .          .          .                   .           .          .           	   size_t __n, size_t __m, size_t __r,
         .          .          .                   .          .          .                   .           .          .           	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
         .          .          .                   .          .          .                   .           .          .           	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
         .          .          .                   .          .          .                   .           .          .           	   _UIntType __f>
         .          .          .                   .          .          .                   .           .          .               void
   144,715 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)     28,943 ( 0.00%) 0          0                   0           0          0               mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
         .          .          .                   .          .          .                   .           .          .           			    __s, __b, __t, __c, __l, __f>::
         .          .          .                   .          .          .                   .           .          .               _M_gen_rand(void)
         .          .          .                   .          .          .                   .           .          .               {
         .          .          .                   .          .          .                   .           .          .                 const _UIntType __upper_mask = (~_UIntType()) << __r;
         .          .          .                   .          .          .                   .           .          .                 const _UIntType __lower_mask = ~__upper_mask;
         .          .          .                   .          .          .                   .           .          .           
19,768,069 ( 0.57%) 1 ( 0.04%) 1 ( 0.04%)     28,943 ( 0.00%) 0          0                   0           0          0                 for (size_t __k = 0; __k < (__n - __m); ++__k)
         .          .          .                   .          .          .                   .           .          .                   {
19,710,183 ( 0.57%) 1 ( 0.04%) 1 ( 0.04%)          0          0          0                   0           0          0           	  _UIntType __y = ((_M_x[__k] & __upper_mask)
19,710,183 ( 0.57%) 0          0           6,570,061 ( 0.79%) 0          0                   0           0          0           			   | (_M_x[__k + 1] & __lower_mask));
26,280,244 ( 0.76%) 0          0           6,570,061 ( 0.79%) 1 ( 0.01%) 0           6,570,061 ( 1.30%)  0          0           	  _M_x[__k] = (_M_x[__k + __m] ^ (__y >> 1)
16,510,662 ( 0.48%) 0          0                   0          0          0                   0           0          0           		       ^ ((__y & 0x01) ? __a : 0));
         .          .          .                   .          .          .                   .           .          .                   }
         .          .          .                   .          .          .                   .           .          .           
34,384,284 ( 0.99%) 0          0                   0          0          0                   0           0          0                 for (size_t __k = (__n - __m); __k < (__n - 1); ++__k)
         .          .          .                   .          .          .                   .           .          .           	{
34,384,284 ( 0.99%) 0          0                   0          0          0                   0           0          0           	  _UIntType __y = ((_M_x[__k] & __upper_mask)
34,384,284 ( 0.99%) 0          0          11,461,428 ( 1.38%) 3 ( 0.02%) 0                   0           0          0           			   | (_M_x[__k + 1] & __lower_mask));
45,845,712 ( 1.32%) 1 ( 0.04%) 1 ( 0.04%) 11,461,428 ( 1.38%) 0          0          11,461,428 ( 2.27%)  0          0           	  _M_x[__k] = (_M_x[__k + (__m - __n)] ^ (__y >> 1)
28,714,257 ( 0.83%) 0          0                   0          0          0                   0           0          0           		       ^ ((__y & 0x01) ? __a : 0));
         .          .          .                   .          .          .                   .           .          .           	}
         .          .          .                   .          .          .                   .           .          .           
    86,829 ( 0.00%) 0          0              28,943 ( 0.00%) 0          0                   0           0          0                 _UIntType __y = ((_M_x[__n - 1] & __upper_mask)
    57,886 ( 0.00%) 0          0              28,943 ( 0.00%) 0          0                   0           0          0           		       | (_M_x[0] & __lower_mask));
   115,772 ( 0.00%) 0          0              28,943 ( 0.00%) 0          0              28,943 ( 0.01%)  0          0                 _M_x[__n - 1] = (_M_x[__m - 1] ^ (__y >> 1)
    86,988 ( 0.00%) 0          0                   0          0          0                   0           0          0           		       ^ ((__y & 0x01) ? __a : 0));
    28,943 ( 0.00%) 0          0                   0          0          0              28,943 ( 0.01%)  0          0                 _M_p = 0;
    28,943 ( 0.00%) 0          0              28,943 ( 0.00%) 0          0                   0           0          0               }
         .          .          .                   .          .          .                   .           .          .           
         .          .          .                   .          .          .                   .           .          .             template<typename _UIntType, size_t __w,
         .          .          .                   .          .          .                   .           .          .           	   size_t __n, size_t __m, size_t __r,
         .          .          .                   .          .          .                   .           .          .           	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
         .          .          .                   .          .          .                   .           .          .           	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
         .          .          .                   .          .          .                   .           .          .           	   _UIntType __f>
         .          .          .                   .          .          .                   .           .          .               void
         .          .          .                   .          .          .                   .           .          .               mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
-- line 430 ----------------------------------------
-- line 447 ----------------------------------------
         .          .          .                   .          .          .                   .           .          .               typename
         .          .          .                   .          .          .                   .           .          .               mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
         .          .          .                   .          .          .                   .           .          .           			    __s, __b, __t, __c, __l, __f>::result_type
         .          .          .                   .          .          .                   .           .          .               mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
         .          .          .                   .          .          .                   .           .          .           			    __s, __b, __t, __c, __l, __f>::
         .          .          .                   .          .          .                   .           .          .               operator()()
         .          .          .                   .          .          .                   .           .          .               {
         .          .          .                   .          .          .                   .           .          .                 // Reload the vector - cost is O(n) amortized over n calls.
54,179,874 ( 1.56%) 4 ( 0.15%) 4 ( 0.16%) 18,059,958 ( 2.18%) 0          0                   0           0          0                 if (_M_p >= state_size)
    40,635 ( 0.00%) 2 ( 0.08%) 2 ( 0.08%)          0          0          0              28,943 ( 0.01%)  0          0           	_M_gen_rand();
         .          .          .                   .          .          .                   .           .          .           
         .          .          .                   .          .          .                   .           .          .                 // Calculate o(x(i)).
54,237,760 ( 1.56%) 0          0          18,088,901 ( 2.18%) 0          0          18,059,958 ( 3.57%)  0          0                 result_type __z = _M_x[_M_p++];
72,239,832 ( 2.08%) 0          0                   0          0          0                   0           0          0                 __z ^= (__z >> __u) & __d;
72,239,832 ( 2.08%) 0          0                   0          0          0                   0           0          0                 __z ^= (__z << __s) & __b;
72,239,832 ( 2.08%) 0          0                   0          0          0                   0           0          0                 __z ^= (__z << __t) & __c;
54,179,874 ( 1.56%) 2 ( 0.08%) 2 ( 0.08%)          0          0          0                   0           0          0                 __z ^= (__z >> __l);
         .          .          .                   .          .          .                   .           .          .           
         .          .          .                   .          .          .                   .           .          .                 return __z;
         .          .          .                   .          .          .                   .           .          .               }
         .          .          .                   .          .          .                   .           .          .           
         .          .          .                   .          .          .                   .           .          .             template<typename _UIntType, size_t __w,
         .          .          .                   .          .          .                   .           .          .           	   size_t __n, size_t __m, size_t __r,
         .          .          .                   .          .          .                   .           .          .           	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
         .          .          .                   .          .          .                   .           .          .           	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
-- line 471 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/stl_vector.h
--------------------------------------------------------------------------------
Ir                  I1mr       ILmr       Dr                  D1mr       DLmr       Dw         D1mw       DLmw       

-- line 90 ----------------------------------------
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .                 struct _Vector_impl_data
         .          .          .                   .          .          .          .          .          .                 {
         .          .          .                   .          .          .          .          .          .           	pointer _M_start;
         .          .          .                   .          .          .          .          .          .           	pointer _M_finish;
         .          .          .                   .          .          .          .          .          .           	pointer _M_end_of_storage;
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .           	_Vector_impl_data() _GLIBCXX_NOEXCEPT
         4 ( 0.00%) 0          0                   0          0          0          2 ( 0.00%) 0          0           	: _M_start(), _M_finish(), _M_end_of_storage()
         .          .          .                   .          .          .          .          .          .           	{ }
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .           #if __cplusplus >= 201103L
         .          .          .                   .          .          .          .          .          .           	_Vector_impl_data(_Vector_impl_data&& __x) noexcept
         .          .          .                   .          .          .          .          .          .           	: _M_start(__x._M_start), _M_finish(__x._M_finish),
         .          .          .                   .          .          .          .          .          .           	  _M_end_of_storage(__x._M_end_of_storage)
         .          .          .                   .          .          .          .          .          .           	{ __x._M_start = __x._M_finish = __x._M_end_of_storage = pointer(); }
         .          .          .                   .          .          .          .          .          .           #endif
-- line 106 ----------------------------------------
-- line 328 ----------------------------------------
         .          .          .                   .          .          .          .          .          .                 _Vector_base(const allocator_type& __a, _Vector_base&& __x)
         .          .          .                   .          .          .          .          .          .                 : _M_impl(_Tp_alloc_type(__a), std::move(__x._M_impl))
         .          .          .                   .          .          .          .          .          .                 { }
         .          .          .                   .          .          .          .          .          .           #endif
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .                 ~_Vector_base() _GLIBCXX_NOEXCEPT
         .          .          .                   .          .          .          .          .          .                 {
         .          .          .                   .          .          .          .          .          .           	_M_deallocate(_M_impl._M_start,
         2 ( 0.00%) 0          0                   1 ( 0.00%) 0          0          0          0          0           		      _M_impl._M_end_of_storage - _M_impl._M_start);
         .          .          .                   .          .          .          .          .          .                 }
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .               public:
         .          .          .                   .          .          .          .          .          .                 _Vector_impl _M_impl;
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .                 pointer
         .          .          .                   .          .          .          .          .          .                 _M_allocate(size_t __n)
         .          .          .                   .          .          .          .          .          .                 {
         .          .          .                   .          .          .          .          .          .           	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
        20 ( 0.00%) 0          0                   0          0          0          0          0          0           	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
         .          .          .                   .          .          .          .          .          .                 }
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .                 void
         .          .          .                   .          .          .          .          .          .                 _M_deallocate(pointer __p, size_t __n)
         .          .          .                   .          .          .          .          .          .                 {
         .          .          .                   .          .          .          .          .          .           	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
        22 ( 0.00%) 0          0                   0          0          0          0          0          0           	if (__p)
         .          .          .                   .          .          .          .          .          .           	  _Tr::deallocate(_M_impl, __p, __n);
         .          .          .                   .          .          .          .          .          .                 }
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .               protected:
         .          .          .                   .          .          .          .          .          .                 void
         .          .          .                   .          .          .          .          .          .                 _M_create_storage(size_t __n)
         .          .          .                   .          .          .          .          .          .                 {
         .          .          .                   .          .          .          .          .          .           	this->_M_impl._M_start = this->_M_allocate(__n);
-- line 361 ----------------------------------------
-- line 672 ----------------------------------------
         .          .          .                   .          .          .          .          .          .                 /**
         .          .          .                   .          .          .          .          .          .                  *  The dtor only erases the elements, and note that if the
         .          .          .                   .          .          .          .          .          .                  *  elements themselves are pointers, the pointed-to memory is
         .          .          .                   .          .          .          .          .          .                  *  not touched in any way.  Managing the pointer is the user's
         .          .          .                   .          .          .          .          .          .                  *  responsibility.
         .          .          .                   .          .          .          .          .          .                  */
         .          .          .                   .          .          .          .          .          .                 ~vector() _GLIBCXX_NOEXCEPT
         .          .          .                   .          .          .          .          .          .                 {
         1 ( 0.00%) 0          0                   1 ( 0.00%) 0          0          0          0          0           	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
         .          .          .                   .          .          .          .          .          .           		      _M_get_Tp_allocator());
         .          .          .                   .          .          .          .          .          .           	_GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC;
         .          .          .                   .          .          .          .          .          .                 }
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .                 /**
         .          .          .                   .          .          .          .          .          .                  *  @brief  %Vector assignment operator.
         .          .          .                   .          .          .          .          .          .                  *  @param  __x  A %vector of identical element and allocator types.
         .          .          .                   .          .          .          .          .          .                  *
-- line 688 ----------------------------------------
-- line 911 ----------------------------------------
         .          .          .                   .          .          .          .          .          .                 crend() const noexcept
         .          .          .                   .          .          .          .          .          .                 { return const_reverse_iterator(begin()); }
         .          .          .                   .          .          .          .          .          .           #endif
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .                 // [23.2.4.2] capacity
         .          .          .                   .          .          .          .          .          .                 /**  Returns the number of elements in the %vector.  */
         .          .          .                   .          .          .          .          .          .                 size_type
         .          .          .                   .          .          .          .          .          .                 size() const _GLIBCXX_NOEXCEPT
        44 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)          2 ( 0.00%) 0          0          0          0          0                 { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .                 /**  Returns the size() of the largest possible %vector.  */
         .          .          .                   .          .          .          .          .          .                 size_type
         .          .          .                   .          .          .          .          .          .                 max_size() const _GLIBCXX_NOEXCEPT
         .          .          .                   .          .          .          .          .          .                 { return _S_max_size(_M_get_Tp_allocator()); }
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .           #if __cplusplus >= 201103L
         .          .          .                   .          .          .          .          .          .                 /**
-- line 927 ----------------------------------------
-- line 1038 ----------------------------------------
         .          .          .                   .          .          .          .          .          .                  *  Note that data access with this operator is unchecked and
         .          .          .                   .          .          .          .          .          .                  *  out_of_range lookups are not defined. (For checked lookups
         .          .          .                   .          .          .          .          .          .                  *  see at().)
         .          .          .                   .          .          .          .          .          .                  */
         .          .          .                   .          .          .          .          .          .                 reference
         .          .          .                   .          .          .          .          .          .                 operator[](size_type __n) _GLIBCXX_NOEXCEPT
         .          .          .                   .          .          .          .          .          .                 {
         .          .          .                   .          .          .          .          .          .           	__glibcxx_requires_subscript(__n);
66,000,000 ( 1.90%) 0          0          30,000,000 ( 3.62%) 0          0          0          0          0           	return *(this->_M_impl._M_start + __n);
         .          .          .                   .          .          .          .          .          .                 }
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .                 /**
         .          .          .                   .          .          .          .          .          .                  *  @brief  Subscript access to the data contained in the %vector.
         .          .          .                   .          .          .          .          .          .                  *  @param __n The index of the element for which data should be
         .          .          .                   .          .          .          .          .          .                  *  accessed.
         .          .          .                   .          .          .          .          .          .                  *  @return  Read-only (constant) reference to data.
         .          .          .                   .          .          .          .          .          .                  *
-- line 1054 ----------------------------------------
-- line 1750 ----------------------------------------
         .          .          .                   .          .          .          .          .          .                 _M_emplace_aux(const_iterator __position, value_type&& __v)
         .          .          .                   .          .          .          .          .          .                 { return _M_insert_rval(__position, std::move(__v)); }
         .          .          .                   .          .          .          .          .          .           #endif
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .                 // Called by _M_fill_insert, _M_insert_aux etc.
         .          .          .                   .          .          .          .          .          .                 size_type
         .          .          .                   .          .          .          .          .          .                 _M_check_len(size_type __n, const char* __s) const
         .          .          .                   .          .          .          .          .          .                 {
        72 ( 0.00%) 0          0                   0          0          0          0          0          0           	if (max_size() - size() < __n)
         .          .          .                   .          .          .          .          .          .           	  __throw_length_error(__N(__s));
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .           	const size_type __len = size() + (std::max)(size(), __n);
         .          .          .                   .          .          .          .          .          .           	return (__len < size() || __len > max_size()) ? max_size() : __len;
         .          .          .                   .          .          .          .          .          .                 }
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .                 // Called by constructors to check initial size.
         .          .          .                   .          .          .          .          .          .                 static size_type
-- line 1766 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/juanb3ltran/Documentos/Universidad/Alto_rendimiento/Cream_drop/Main/utils.cpp
--------------------------------------------------------------------------------
Ir                   I1mr       ILmr       Dr                  D1mr       DLmr       Dw                  D1mw        DLmw        

          .          .          .                   .          .          .                   .           .           .           #include "utils.hpp"
          .          .          .                   .          .          .                   .           .           .           
          .          .          .                   .          .          .                   .           .           .           //Implementación de funciones
 48,000,000 ( 1.38%) 2 ( 0.08%) 2 ( 0.08%)          0          0          0          30,000,000 ( 5.93%)  0           0           int getRandomInt(int max, std::mt19937& gen, bool positive) {
 12,000,000 ( 0.35%) 0          0                   0          0          0                   0           0           0               if (positive)
          .          .          .                   .          .          .                   .           .           .               {
          .          .          .                   .          .          .                   .           .           .                   std::uniform_int_distribution<int> dist_(0, max);
          .          .          .                   .          .          .                   .           .           .                   return dist_(gen);
          .          .          .                   .          .          .                   .           .           .               }
          .          .          .                   .          .          .                   .           .           .               else
          .          .          .                   .          .          .                   .           .           .               {
          .          .          .                   .          .          .                   .           .           .                   std::uniform_int_distribution<int> dist_(-max, max);
          .          .          .                   .          .          .                   .           .           .                   return dist_(gen);
          .          .          .                   .          .          .                   .           .           .               }
          .          .          .                   .          .          .                   .           .           .               
 36,000,000 ( 1.04%) 0          0          36,000,000 ( 4.34%) 0          0                   0           0           0           }
          .          .          .                   .          .          .                   .           .           .           
         12 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)          0          0          0                   7 ( 0.00%)  0           0           void inicializar(std::vector<Particle> &balls, int N_particles, double Size, bool initCenter){
      1,203 ( 0.00%) 2 ( 0.08%) 2 ( 0.08%)          0          0          0                   0           0           0               for (int i = 0; i < N_particles; ++i) {
          .          .          .                   .          .          .                   .           .           .                   balls.emplace_back(0, 0); // Cada partícula inicia en (0,0)
          .          .          .                   .          .          .                   .           .           .               }
          .          .          .                   .          .          .                   .           .           .           
          .          .          .                   .          .          .                   .           .           .               // Si se quiere que empiecen en el centro, se salta esto, si no, sigue
          2 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)          0          0          0                   0           0           0               if (!initCenter){
          .          .          .                   .          .          .                   .           .           .                   // Se genera el cuadrado inicial
          2 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)          1 ( 0.00%) 0          0                   0           0           0                   if(std::sqrt(N_particles) > Size){throw std::logic_error(" \n Particles can't fit in the container, increase its size or decrease number of particles.\n");}
          1 ( 0.00%) 0          0                   0          0          0                   0           0           0                   int square_size = std::sqrt(N_particles);
          5 ( 0.00%) 0          0                   0          0          0                   0           0           0                   if(square_size*square_size != balls.size()){throw std::logic_error(" \n  Number of particles does not form a perfect square.\n");}
          .          .          .                   .          .          .                   .           .           .           
          2 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)          0          0          0                   0           0           0                   int i=0;
         66 ( 0.00%) 0          0                   0          0          0                   0           0           0                   for(double ix=0; ix < square_size; ix++){
      1,620 ( 0.00%) 0          0                   0          0          0                   0           0           0                       for (double iy=0; iy < square_size; iy++){            
        123 ( 0.00%) 0          0                   1 ( 0.00%) 0          0                   0           0           0                           balls[i].setX(ix - square_size/2);
        800 ( 0.00%) 0          0                   0          0          0                   0           0           0                           balls[i].setY(iy - square_size/2);
          .          .          .                   .          .          .                   .           .           .                           // std::cout<< balls[i].getX() <<","<< balls[i].getY() <<std::endl;
        400 ( 0.00%) 0          0                   0          0          0                   0           0           0                           i++;
          .          .          .                   .          .          .                   .           .           .                       }
          .          .          .                   .          .          .                   .           .           .                   }     
          .          .          .                   .          .          .                   .           .           .               }      
          8 ( 0.00%) 0          0                   7 ( 0.00%) 0          0                   0           0           0           }
          .          .          .                   .          .          .                   .           .           .           
          .          .          .                   .          .          .                   .           .           .           //Calcula la distancia RMS de las particulas desde el origen
          .          .          .                   .          .          .                   .           .           .           double rms_distance(const std::vector<Particle> &walkers){
          .          .          .                   .          .          .                   .           .           .               double square_sum = 0.0;
          .          .          .                   .          .          .                   .           .           .               double x = 0.0, y = 0.0, norm = 0.0;
          .          .          .                   .          .          .                   .           .           .               for(const Particle walker : walkers){
          .          .          .                   .          .          .                   .           .           .                   x = walker.getX();
          .          .          .                   .          .          .                   .           .           .                   y = walker.getY();
-- line 48 ----------------------------------------
-- line 53 ----------------------------------------
          .          .          .                   .          .          .                   .           .           .               return std::sqrt(square_sum/walkers.size());
          .          .          .                   .          .          .                   .           .           .           }
          .          .          .                   .          .          .                   .           .           .           
          .          .          .                   .          .          .                   .           .           .           //Funciones de entropía
          .          .          .                   .          .          .                   .           .           .           
          .          .          .                   .          .          .                   .           .           .           
          .          .          .                   .          .          .                   .           .           .           void counts(std::unordered_map<int,int>& entropyGrid, double x, double y, 
          .          .          .                   .          .          .                   .           .           .                       double x_min, double x_max, double y_min, double y_max, int divisions)
      2,000 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)        400 ( 0.00%) 0          0                 400 ( 0.00%)  0           0           {
          .          .          .                   .          .          .                   .           .           .               //Calcula el tamaño de cada subdivision en terminos de las coordenadas de posicion
      1,600 ( 0.00%) 0          0                   0          0          0                   0           0           0               double x_step = (x_max - x_min) / static_cast<double>(divisions);
        800 ( 0.00%) 0          0                   0          0          0                   0           0           0               double y_step = (y_max - y_min) / static_cast<double>(divisions);
          .          .          .                   .          .          .                   .           .           .           
          .          .          .                   .          .          .                   .           .           .               //Verifica la posicion dentro de los limites
      3,200 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)          0          0          0                   0           0           0                   if ((x_min <= x) && (x <= x_max) && (y_min <= y) && (y <= y_max))
          .          .          .                   .          .          .                   .           .           .                   {
          .          .          .                   .          .          .                   .           .           .                       // Calcula el índice de la subdivisión para x e y
      1,200 ( 0.00%) 0          0                   0          0          0                   0           0           0                       int ix = int((x - x_min) / x_step);
      1,200 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)          0          0          0                   0           0           0                       int iy = int((y - y_min) / y_step);
          .          .          .                   .          .          .                   .           .           .           
          .          .          .                   .          .          .                   .           .           .                       // Se suma uno a ese índice (esa celda)
      1,600 ( 0.00%) 0          0                 400 ( 0.00%) 0          0                 400 ( 0.00%)  0           0                       entropyGrid[ix*divisions + iy]++;
          .          .          .                   .          .          .                   .           .           .                   }
      2,400 ( 0.00%) 0          0               1,200 ( 0.00%) 0          0                   0           0           0           }
          .          .          .                   .          .          .                   .           .           .           
          .          .          .                   .          .          .                   .           .           .           double compute_entropy(std::unordered_map<int, int>& entropyGrid, int N_particles)
          3 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)          0          0          0                   1 ( 0.00%)  0           0           {
          .          .          .                   .          .          .                   .           .           .               // Calcula la entropía
          1 ( 0.00%) 0          0                   0          0          0                   0           0           0               double entropy = 0.0;
          .          .          .                   .          .          .                   .           .           .           
         10 ( 0.00%) 0          0                   0          0          0                   0           0           0               for (const auto& pair : entropyGrid) {
         20 ( 0.00%) 0          0                   8 ( 0.00%) 0          0                   5 ( 0.00%)  0           0                   double p = double(pair.second) / N_particles;
         28 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)          8 ( 0.00%) 0          0                   8 ( 0.00%)  0           0                   entropy -= p * std::log(p);
          .          .          .                   .          .          .                   .           .           .               }
          .          .          .                   .          .          .                   .           .           .           
          .          .          .                   .          .          .                   .           .           .               return entropy;
          4 ( 0.00%) 0          0                   2 ( 0.00%) 0          0                   0           0           0           }
          .          .          .                   .          .          .                   .           .           .           
          .          .          .                   .          .          .                   .           .           .           
          .          .          .                   .          .          .                   .           .           .           double delta_entropy(std::unordered_map<int, int>& entropyGrid, double new_x, double new_y, 
          .          .          .                   .          .          .                   .           .           .                               double x_min, double x_max, double y_min, double y_max, int divisions, double old_x, double old_y, int N_particles)
 84,000,000 ( 2.42%) 1 ( 0.04%) 1 ( 0.04%)  6,000,000 ( 0.72%) 0          0          42,000,000 ( 8.31%)  0           0           {
          .          .          .                   .          .          .                   .           .           .               //Calcula el cambio en la entropia teniendo en cuenta la subdivision de donde sale y a que llega una particula
          .          .          .                   .          .          .                   .           .           .           
 24,000,000 ( 0.69%) 0          0                   0          0          0                   0           0           0               double x_step = (x_max - x_min) / divisions;
 12,000,000 ( 0.35%) 1 ( 0.04%) 1 ( 0.04%)          0          0          0                   0           0           0               double y_step = (y_max - y_min) / divisions;
          .          .          .                   .          .          .                   .           .           .           
 18,000,000 ( 0.52%) 0          0                   0          0          0                   0           0           0               int old_ix = int((old_x - x_min) / x_step); //Indices de la subdivision con la posicion anterior (origen)
 18,000,000 ( 0.52%) 0          0                   0          0          0                   0           0           0               int old_iy = int((old_y - y_min) / y_step);
          .          .          .                   .          .          .                   .           .           .           
 18,000,000 ( 0.52%) 0          0                   0          0          0                   0           0           0               int new_ix = int((new_x - x_min) / x_step); //Indices de la subdivision con la posicion actual (destino)
 18,000,000 ( 0.52%) 0          0                   0          0          0                   0           0           0               int new_iy = int((new_y - y_min) / y_step);
          .          .          .                   .          .          .                   .           .           .           
 23,705,880 ( 0.68%) 0          0                   0          0          0                   0           0           0               if ((old_ix == new_ix) && (old_iy == new_iy))
          .          .          .                   .          .          .                   .           .           .               {
          .          .          .                   .          .          .                   .           .           .                   //Si la particula no cambio de subdivision entonces la entropia no cambio
  5,852,940 ( 0.17%) 0          0                   0          0          0                   0           0           0                   return 0.0;
          .          .          .                   .          .          .                   .           .           .               }
          .          .          .                   .          .          .                   .           .           .               else //la particula cambio de subdivision por lo que se calcula los terminos de probabilidad antes y despues del cambio 
          .          .          .                   .          .          .                   .           .           .               {   
  2,889,810 ( 0.08%) 1 ( 0.04%) 1 ( 0.04%)    288,981 ( 0.03%) 0          0             866,943 ( 0.17%)  0           0                   double old_p1 = double(entropyGrid[old_ix*divisions + old_iy]) / N_particles; //probabilidad antigua de la subdivision 1 (origen)
  2,311,848 ( 0.07%) 1 ( 0.04%) 1 ( 0.04%)    866,943 ( 0.10%) 0          0             577,962 ( 0.11%)  0           0                   double old_p2 = double(entropyGrid[new_ix*divisions + new_iy]) / N_particles; //probabilidad antigua de la subdivision 2 (destino) Si el índice no está en el mapa, su valor es 0 por default
          .          .          .                   .          .          .                   .           .           .           
          .          .          .                   .          .          .                   .           .           .                   // Ajusta el contador para la subdivision donde estaba la particula y a la cual llego
    577,962 ( 0.02%) 0          0             288,981 ( 0.03%) 0          0             288,981 ( 0.06%)  0           0                   entropyGrid[new_ix*divisions + new_iy]++;
    577,962 ( 0.02%) 0          0             288,981 ( 0.03%) 0          0             288,981 ( 0.06%)  0           0                   entropyGrid[old_ix*divisions + old_iy]--;
          .          .          .                   .          .          .                   .           .           .                   
          .          .          .                   .          .          .                   .           .           .           
  1,444,905 ( 0.04%) 0          0             577,962 ( 0.07%) 0          0             577,962 ( 0.11%)  0           0                   double new_p1 = double(entropyGrid[old_ix*divisions + old_iy]) / N_particles; //probabilidad nueva de la subdivision 1 (origen)
  1,155,924 ( 0.03%) 0          0             577,962 ( 0.07%) 0          0             288,981 ( 0.06%)  0           0                   double new_p2 = double(entropyGrid[new_ix*divisions + new_iy]) / N_particles; //probabilidad nueva de la subdivision 2 (destino)
          .          .          .                   .          .          .                   .           .           .           
    288,981 ( 0.01%) 0          0                   0          0          0                   0           0           0                   double ds = 0;
          .          .          .                   .          .          .                   .           .           .                   //old_p1*log(old_p1)-new_p1*log(new_p1) + old_p2*log(old_p2)-new_p2*log(new_p2); //Cambio en la entropia 
  4,623,696 ( 0.13%) 2 ( 0.08%) 2 ( 0.08%)    866,943 ( 0.10%) 0          0             866,943 ( 0.17%)  0           0                   if (old_p1!=0){ds+=old_p1*log(old_p1);}
  4,029,034 ( 0.12%) 1 ( 0.04%) 1 ( 0.04%)  1,438,225 ( 0.17%) 0          0             861,933 ( 0.17%)  0           0                   if (new_p1!=0){ds-=new_p1*log(new_p1);}
  4,028,434 ( 0.12%) 1 ( 0.04%) 1 ( 0.04%)  1,437,985 ( 0.17%) 0          0             861,753 ( 0.17%)  0           0                   if (old_p2!=0){ds+=old_p2*log(old_p2);}
  3,467,772 ( 0.10%) 0          0             577,962 ( 0.07%) 0          0             866,943 ( 0.17%)  0           0                   if (new_p2!=0){ds-=new_p2*log(new_p2);}
          .          .          .                   .          .          .                   .           .           .                   return ds;
          .          .          .                   .          .          .                   .           .           .               }    
 72,000,000 ( 2.07%) 0          0          54,000,000 ( 6.51%) 0          0                   0           0           0           }
          .          .          .                   .          .          .                   .           .           .           
          .          .          .                   .          .          .                   .           .           .           //Implementación de la clase Particle
          .          .          .                   .          .          .                   .           .           .           
        401 ( 0.00%) 0          0                   0          0          0                 400 ( 0.00%) 99 ( 3.48%) 99 ( 5.37%)  Particle::Particle(double initialX, double initialY): x(initialX), y(initialY){}
          .          .          .                   .          .          .                   .           .           .           
 12,000,400 ( 0.35%) 0          0                   0          0          0                   0           0           0           double Particle::getX() const{
 12,000,400 ( 0.35%) 0          0          12,000,400 ( 1.45%) 0          0                   0           0           0               return x;
 12,000,400 ( 0.35%) 0          0          12,000,400 ( 1.45%) 0          0                   0           0           0           }
          .          .          .                   .          .          .                   .           .           .           
 12,000,400 ( 0.35%) 1 ( 0.04%) 1 ( 0.04%)          0          0          0                   0           0           0           double Particle::getY() const{
 12,000,400 ( 0.35%) 0          0          12,000,400 ( 1.45%) 0          0                   0           0           0               return y;
 12,000,400 ( 0.35%) 0          0          12,000,400 ( 1.45%) 0          0                   0           0           0           }
          .          .          .                   .          .          .                   .           .           .           
          .          .          .                   .          .          .                   .           .           .           void Particle::setX(double newX){
  6,001,200 ( 0.17%) 0          0                   0          0          0           6,000,400 ( 1.19%)  0           0               x=newX;
          .          .          .                   .          .          .                   .           .           .           }
          .          .          .                   .          .          .                   .           .           .           
          .          .          .                   .          .          .                   .           .           .           void Particle::setY(double newY){
          .          .          .                   .          .          .                   .           .           .               y=newY;
          .          .          .                   .          .          .                   .           .           .           }
          .          .          .                   .          .          .                   .           .           .           
          .          .          .                   .          .          .                   .           .           .           void Particle::move(double dx, double dy){
          .          .          .                   .          .          .                   .           .           .               x+=dx;
          .          .          .                   .          .          .                   .           .           .               y+=dy;
          .          .          .                   .          .          .                   .           .           .           }
          .          .          .                   .          .          .                   .           .           .           
          .          .          .                   .          .          .                   .           .           .           // Otra función para el mov de las partículas
108,000,000 ( 3.11%) 2 ( 0.08%) 2 ( 0.08%)  6,000,000 ( 0.72%) 0          0          54,000,000 (10.68%)  0           0           void Particle::moveRandom(double delta, double x_min, double x_max, double y_min, double y_max, std::mt19937& gen){
          .          .          .                   .          .          .                   .           .           .               
 36,000,000 ( 1.04%) 0          0           6,000,000 ( 0.72%) 0          0          24,000,000 ( 4.75%)  0           0                   std::vector<double> possibleMoves = {-delta, 0.0, delta};
          .          .          .                   .          .          .                   .           .           .           
          .          .          .                   .          .          .                   .           .           .                   // Se inicializan valores fuera de límites para garantizar que se haga el while de abajo
 48,000,000 ( 1.38%) 1 ( 0.04%) 1 ( 0.04%)  6,000,000 ( 0.72%) 0          0                   0           0           0                   double newX = x_min - delta*2;
          .          .          .                   .          .          .                   .           .           .                   double newY = y_min - delta*2;
          .          .          .                   .          .          .                   .           .           .           
          .          .          .                   .          .          .                   .           .           .                   // Se hará este ciclo hasta que se encuentre una nueva posición válida para la partícula
          .          .          .                   .          .          .                   .           .           .                   // Siempre habrá un movimiento posible (mínimo 3 creo)
108,280,799 ( 3.12%) 2 ( 0.08%) 2 ( 0.08%) 12,031,174 ( 1.45%) 0          0                   0           0           0                   while (newX <= x_min || newX >= x_max || newY <= y_min || newY >= y_max){
          .          .          .                   .          .          .                   .           .           .                       int index0 = getRandomInt(possibleMoves.size() - 1, gen);
          .          .          .                   .          .          .                   .           .           .                       int index1 = getRandomInt(possibleMoves.size() - 1, gen);
 24,119,916 ( 0.69%) 0          0          18,089,937 ( 2.18%) 0          0                   0           0           0                       newX = x + possibleMoves[index0];
  6,029,979 ( 0.17%) 0          0                   0          0          0                   0           0           0                       newY = y + possibleMoves[index1];
          .          .          .                   .          .          .                   .           .           .                   }
          .          .          .                   .          .          .                   .           .           .           
          .          .          .                   .          .          .                   .           .           .                   // Se actualiza la posición
          .          .          .                   .          .          .                   .           .           .                   setX(newX); setY(newY);
 42,000,000 ( 1.21%) 1 ( 0.04%) 1 ( 0.04%) 36,000,000 ( 4.34%) 0          0                   0           0           0           }
          .          .          .                   .          .          .                   .           .           .           
          .          .          .                   .          .          .                   .           .           .           
          .          .          .                   .          .          .                   .           .           .           // Función para mover las partículas. Devuelve el estado de la partícula (0: dentro, 1: salió por el hueco)
          .          .          .                   .          .          .                   .           .           .           int Particle::moveRandomwHole(double delta, double x_min, double x_max, double y_min, double y_max, std::vector<double> holeinWall, std::mt19937& gen){
          .          .          .                   .          .          .                   .           .           .           
          .          .          .                   .          .          .                   .           .           .               std::vector<double> possibleMoves = {-delta, 0.0, delta};
          .          .          .                   .          .          .                   .           .           .               double newX;
          .          .          .                   .          .          .                   .           .           .               double newY;
-- line 187 ----------------------------------------
-- line 209 ----------------------------------------
          .          .          .                   .          .          .                   .           .           .                   }
          .          .          .                   .          .          .                   .           .           .               }
          .          .          .                   .          .          .                   .           .           .           }
          .          .          .                   .          .          .                   .           .           .           
          .          .          .                   .          .          .                   .           .           .           // Determina si la partícula salió por el hueco
          .          .          .                   .          .          .                   .           .           .           bool goneThroughWhole(double x, double y, std::vector<double> holeinWall, double delta){
          .          .          .                   .          .          .                   .           .           .               return (x > holeinWall[0]-delta && x < holeinWall[0]+delta + holeinWall[2] && y > holeinWall[1]);
          .          .          .                   .          .          .                   .           .           .               // Se suma el delta para tener en cuenta los casos en los que la partícula esté cerca al hueco y salga en diagonal
          3 ( 0.00%) 0          0                   1 ( 0.00%) 0          0                   1 ( 0.00%)  0           0           }
          .          .          .                   .          .          .                   .           .           .           

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/hashtable.h
--------------------------------------------------------------------------------
Ir                 I1mr       ILmr       Dr                 D1mr       DLmr       Dw           D1mw       DLmw       

-- line 300 ----------------------------------------
        .          .          .                  .          .          .            .          .          .           	// Allocate a node and construct an element within it.
        .          .          .                  .          .          .            .          .          .           	template<typename... _Args>
        .          .          .                  .          .          .            .          .          .           	  _Scoped_node(__hashtable_alloc* __h, _Args&&... __args)
        .          .          .                  .          .          .            .          .          .           	  : _M_h(__h),
        .          .          .                  .          .          .            .          .          .           	    _M_node(__h->_M_allocate_node(std::forward<_Args>(__args)...))
        .          .          .                  .          .          .            .          .          .           	  { }
        .          .          .                  .          .          .            .          .          .           
        .          .          .                  .          .          .            .          .          .           	// Destroy element and deallocate node.
       64 ( 0.00%) 0          0                  0          0          0            0          0          0           	~_Scoped_node() { if (_M_node) _M_h->_M_deallocate_node(_M_node); };
        .          .          .                  .          .          .            .          .          .           
        .          .          .                  .          .          .            .          .          .           	_Scoped_node(const _Scoped_node&) = delete;
        .          .          .                  .          .          .            .          .          .           	_Scoped_node& operator=(const _Scoped_node&) = delete;
        .          .          .                  .          .          .            .          .          .           
        .          .          .                  .          .          .            .          .          .           	__hashtable_alloc* _M_h;
        .          .          .                  .          .          .            .          .          .           	__node_ptr _M_node;
        .          .          .                  .          .          .            .          .          .                 };
        .          .          .                  .          .          .            .          .          .           
-- line 316 ----------------------------------------
-- line 414 ----------------------------------------
        .          .          .                  .          .          .            .          .          .                 _M_update_bbegin(__node_ptr __n)
        .          .          .                  .          .          .            .          .          .                 {
        .          .          .                  .          .          .            .          .          .           	_M_before_begin._M_nxt = __n;
        .          .          .                  .          .          .            .          .          .           	_M_update_bbegin();
        .          .          .                  .          .          .            .          .          .                 }
        .          .          .                  .          .          .            .          .          .           
        .          .          .                  .          .          .            .          .          .                 bool
        .          .          .                  .          .          .            .          .          .                 _M_uses_single_bucket(__buckets_ptr __bkts) const
        1 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         0          0          0            0          0          0                 { return __builtin_expect(__bkts == &_M_single_bucket, false); }
        .          .          .                  .          .          .            .          .          .           
        .          .          .                  .          .          .            .          .          .                 bool
        .          .          .                  .          .          .            .          .          .                 _M_uses_single_bucket() const
        .          .          .                  .          .          .            .          .          .                 { return _M_uses_single_bucket(_M_buckets); }
        .          .          .                  .          .          .            .          .          .           
        .          .          .                  .          .          .            .          .          .                 __hashtable_alloc&
        .          .          .                  .          .          .            .          .          .                 _M_base_alloc() { return *this; }
        .          .          .                  .          .          .            .          .          .           
        .          .          .                  .          .          .            .          .          .                 __buckets_ptr
        .          .          .                  .          .          .            .          .          .                 _M_allocate_buckets(size_type __bkt_count)
        .          .          .                  .          .          .            .          .          .                 {
        8 ( 0.00%) 0          0                  0          0          0            0          0          0           	if (__builtin_expect(__bkt_count == 1, false))
        .          .          .                  .          .          .            .          .          .           	  {
        .          .          .                  .          .          .            .          .          .           	    _M_single_bucket = nullptr;
        4 ( 0.00%) 0          0                  0          0          0            0          0          0           	    return &_M_single_bucket;
        .          .          .                  .          .          .            .          .          .           	  }
        .          .          .                  .          .          .            .          .          .           
        .          .          .                  .          .          .            .          .          .           	return __hashtable_alloc::_M_allocate_buckets(__bkt_count);
        .          .          .                  .          .          .            .          .          .                 }
        .          .          .                  .          .          .            .          .          .           
        .          .          .                  .          .          .            .          .          .                 void
        .          .          .                  .          .          .            .          .          .                 _M_deallocate_buckets(__buckets_ptr __bkts, size_type __bkt_count)
        .          .          .                  .          .          .            .          .          .                 {
       10 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         0          0          0            0          0          0           	if (_M_uses_single_bucket(__bkts))
        .          .          .                  .          .          .            .          .          .           	  return;
        .          .          .                  .          .          .            .          .          .           
        .          .          .                  .          .          .            .          .          .           	__hashtable_alloc::_M_deallocate_buckets(__bkts, __bkt_count);
        .          .          .                  .          .          .            .          .          .                 }
        .          .          .                  .          .          .            .          .          .           
        .          .          .                  .          .          .            .          .          .                 void
        .          .          .                  .          .          .            .          .          .                 _M_deallocate_buckets()
       10 ( 0.00%) 0          0                 10 ( 0.00%) 0          0            0          0          0                 { _M_deallocate_buckets(_M_buckets, _M_bucket_count); }
        .          .          .                  .          .          .            .          .          .           
        .          .          .                  .          .          .            .          .          .                 // Gets bucket begin, deals with the fact that non-empty buckets contain
        .          .          .                  .          .          .            .          .          .                 // their before begin node.
        .          .          .                  .          .          .            .          .          .                 __node_ptr
        .          .          .                  .          .          .            .          .          .                 _M_bucket_begin(size_type __bkt) const;
        .          .          .                  .          .          .            .          .          .           
        .          .          .                  .          .          .            .          .          .                 __node_ptr
        .          .          .                  .          .          .            .          .          .                 _M_begin() const
        6 ( 0.00%) 0          0                  6 ( 0.00%) 0          0            0          0          0                 { return static_cast<__node_ptr>(_M_before_begin._M_nxt); }
        .          .          .                  .          .          .            .          .          .           
        .          .          .                  .          .          .            .          .          .                 // Assign *this using another _Hashtable instance. Whether elements
        .          .          .                  .          .          .            .          .          .                 // are copied or moved depends on the _Ht reference.
        .          .          .                  .          .          .            .          .          .                 template<typename _Ht>
        .          .          .                  .          .          .            .          .          .           	void
        .          .          .                  .          .          .            .          .          .           	_M_assign_elements(_Ht&&);
        .          .          .                  .          .          .            .          .          .           
        .          .          .                  .          .          .            .          .          .                 template<typename _Ht, typename _NodeGenerator>
-- line 471 ----------------------------------------
-- line 520 ----------------------------------------
        .          .          .                  .          .          .            .          .          .                 template<typename _InputIterator>
        .          .          .                  .          .          .            .          .          .           	_Hashtable(_InputIterator __first, _InputIterator __last,
        .          .          .                  .          .          .            .          .          .           		   size_type __bkt_count_hint,
        .          .          .                  .          .          .            .          .          .           		   const _Hash&, const _Equal&, const allocator_type&,
        .          .          .                  .          .          .            .          .          .           		   false_type __uks);
        .          .          .                  .          .          .            .          .          .           
        .          .          .                  .          .          .            .          .          .               public:
        .          .          .                  .          .          .            .          .          .                 // Constructor, destructor, assignment, swap
        6 ( 0.00%) 0          0                  0          0          0            4 ( 0.00%) 1 ( 0.04%) 0                 _Hashtable() = default;
        .          .          .                  .          .          .            .          .          .           
        .          .          .                  .          .          .            .          .          .                 _Hashtable(const _Hashtable&);
        .          .          .                  .          .          .            .          .          .           
        .          .          .                  .          .          .            .          .          .                 _Hashtable(const _Hashtable&, const allocator_type&);
        .          .          .                  .          .          .            .          .          .           
        .          .          .                  .          .          .            .          .          .                 explicit
        .          .          .                  .          .          .            .          .          .                 _Hashtable(size_type __bkt_count_hint,
        .          .          .                  .          .          .            .          .          .           		 const _Hash& __hf = _Hash(),
-- line 536 ----------------------------------------
-- line 787 ----------------------------------------
        .          .          .                  .          .          .            .          .          .               private:
        .          .          .                  .          .          .            .          .          .                 // Bucket index computation helpers.
        .          .          .                  .          .          .            .          .          .                 size_type
        .          .          .                  .          .          .            .          .          .                 _M_bucket_index(const __node_value_type& __n) const noexcept
        .          .          .                  .          .          .            .          .          .                 { return __hash_code_base::_M_bucket_index(__n, _M_bucket_count); }
        .          .          .                  .          .          .            .          .          .           
        .          .          .                  .          .          .            .          .          .                 size_type
        .          .          .                  .          .          .            .          .          .                 _M_bucket_index(__hash_code __c) const
1,734,286 ( 0.05%) 0          0          1,734,286 ( 0.21%) 0          0            0          0          0                 { return __hash_code_base::_M_bucket_index(__c, _M_bucket_count); }
        .          .          .                  .          .          .            .          .          .           
        .          .          .                  .          .          .            .          .          .                 // Find and insert helper functions and types
        .          .          .                  .          .          .            .          .          .                 // Find the node before the one matching the criteria.
        .          .          .                  .          .          .            .          .          .                 __node_base_ptr
        .          .          .                  .          .          .            .          .          .                 _M_find_before_node(size_type, const key_type&, __hash_code) const;
        .          .          .                  .          .          .            .          .          .           
        .          .          .                  .          .          .            .          .          .                 template<typename _Kt>
        .          .          .                  .          .          .            .          .          .           	__node_base_ptr
-- line 803 ----------------------------------------
-- line 1520 ----------------------------------------
        .          .          .                  .          .          .            .          .          .           	  __ht.clear();
        .          .          .                  .          .          .            .          .          .           	}
        .          .          .                  .          .          .            .          .          .               }
        .          .          .                  .          .          .            .          .          .           
        .          .          .                  .          .          .            .          .          .             template<typename _Key, typename _Value, typename _Alloc,
        .          .          .                  .          .          .            .          .          .           	   typename _ExtractKey, typename _Equal,
        .          .          .                  .          .          .            .          .          .           	   typename _Hash, typename _RangeHash, typename _Unused,
        .          .          .                  .          .          .            .          .          .           	   typename _RehashPolicy, typename _Traits>
        5 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         0          0          0            2 ( 0.00%) 0          0               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        .          .          .                  .          .          .            .          .          .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
        .          .          .                  .          .          .            .          .          .               ~_Hashtable() noexcept
        .          .          .                  .          .          .            .          .          .               {
        .          .          .                  .          .          .            .          .          .                 clear();
        .          .          .                  .          .          .            .          .          .                 _M_deallocate_buckets();
        3 ( 0.00%) 0          0                  2 ( 0.00%) 0          0            0          0          0               }
        .          .          .                  .          .          .            .          .          .           
        .          .          .                  .          .          .            .          .          .             template<typename _Key, typename _Value, typename _Alloc,
        .          .          .                  .          .          .            .          .          .           	   typename _ExtractKey, typename _Equal,
        .          .          .                  .          .          .            .          .          .           	   typename _Hash, typename _RangeHash, typename _Unused,
        .          .          .                  .          .          .            .          .          .           	   typename _RehashPolicy, typename _Traits>
        .          .          .                  .          .          .            .          .          .               void
        .          .          .                  .          .          .            .          .          .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        .          .          .                  .          .          .            .          .          .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
-- line 1542 ----------------------------------------
-- line 1825 ----------------------------------------
        .          .          .                  .          .          .            .          .          .           	   typename _RehashPolicy, typename _Traits>
        .          .          .                  .          .          .            .          .          .               auto
        .          .          .                  .          .          .            .          .          .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        .          .          .                  .          .          .            .          .          .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
        .          .          .                  .          .          .            .          .          .               _M_find_before_node(size_type __bkt, const key_type& __k,
        .          .          .                  .          .          .            .          .          .           			__hash_code __code) const
        .          .          .                  .          .          .            .          .          .               -> __node_base_ptr
        .          .          .                  .          .          .            .          .          .               {
5,202,858 ( 0.15%) 0          0          3,468,572 ( 0.42%) 0          0            0          0          0                 __node_base_ptr __prev_p = _M_buckets[__bkt];
3,468,572 ( 0.10%) 0          0                  0          0          0            0          0          0                 if (!__prev_p)
        .          .          .                  .          .          .            .          .          .           	return nullptr;
        .          .          .                  .          .          .            .          .          .           
5,202,696 ( 0.15%) 0          0          1,734,232 ( 0.21%) 0          0            0          0          0                 for (__node_ptr __p = static_cast<__node_ptr>(__prev_p->_M_nxt);;
        .          .          .                  .          .          .            .          .          .           	   __p = __p->_M_next())
        .          .          .                  .          .          .            .          .          .           	{
        .          .          .                  .          .          .            .          .          .           	  if (this->_M_equals(__k, __code, *__p))
        .          .          .                  .          .          .            .          .          .           	    return __prev_p;
        .          .          .                  .          .          .            .          .          .           
    4,690 ( 0.00%) 0          0                938 ( 0.00%) 0          0            0          0          0           	  if (!__p->_M_nxt || _M_bucket_index(*__p->_M_next()) != __bkt)
        .          .          .                  .          .          .            .          .          .           	    break;
        .          .          .                  .          .          .            .          .          .           	  __prev_p = __p;
        .          .          .                  .          .          .            .          .          .           	}
        .          .          .                  .          .          .            .          .          .           
        .          .          .                  .          .          .            .          .          .                 return nullptr;
        .          .          .                  .          .          .            .          .          .               }
        .          .          .                  .          .          .            .          .          .           
        .          .          .                  .          .          .            .          .          .             template<typename _Key, typename _Value, typename _Alloc,
-- line 1851 ----------------------------------------
-- line 1882 ----------------------------------------
        .          .          .                  .          .          .            .          .          .           	   typename _ExtractKey, typename _Equal,
        .          .          .                  .          .          .            .          .          .           	   typename _Hash, typename _RangeHash, typename _Unused,
        .          .          .                  .          .          .            .          .          .           	   typename _RehashPolicy, typename _Traits>
        .          .          .                  .          .          .            .          .          .               void
        .          .          .                  .          .          .            .          .          .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        .          .          .                  .          .          .            .          .          .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
        .          .          .                  .          .          .            .          .          .               _M_insert_bucket_begin(size_type __bkt, __node_ptr __node)
        .          .          .                  .          .          .            .          .          .               {
      328 ( 0.00%) 0          0                128 ( 0.00%) 0          0            0          0          0                 if (_M_buckets[__bkt])
        .          .          .                  .          .          .            .          .          .           	{
        .          .          .                  .          .          .            .          .          .           	  // Bucket is not empty, we just need to insert the new node
        .          .          .                  .          .          .            .          .          .           	  // after the bucket before begin.
       16 ( 0.00%) 0          0                  8 ( 0.00%) 0          0            8 ( 0.00%) 0          0           	  __node->_M_nxt = _M_buckets[__bkt]->_M_nxt;
       16 ( 0.00%) 0          0                  8 ( 0.00%) 0          0            8 ( 0.00%) 0          0           	  _M_buckets[__bkt]->_M_nxt = __node;
        .          .          .                  .          .          .            .          .          .           	}
        .          .          .                  .          .          .            .          .          .                 else
        .          .          .                  .          .          .            .          .          .           	{
        .          .          .                  .          .          .            .          .          .           	  // The bucket is empty, the new node is inserted at the
        .          .          .                  .          .          .            .          .          .           	  // beginning of the singly-linked list and the bucket will
        .          .          .                  .          .          .            .          .          .           	  // contain _M_before_begin pointer.
      112 ( 0.00%) 0          0                 56 ( 0.00%) 0          0           56 ( 0.00%) 0          0           	  __node->_M_nxt = _M_before_begin._M_nxt;
       56 ( 0.00%) 0          0                  0          0          0           56 ( 0.00%) 0          0           	  _M_before_begin._M_nxt = __node;
        .          .          .                  .          .          .            .          .          .           
      112 ( 0.00%) 0          0                  0          0          0            0          0          0           	  if (__node->_M_nxt)
        .          .          .                  .          .          .            .          .          .           	    // We must update former begin bucket that is pointing to
        .          .          .                  .          .          .            .          .          .           	    // _M_before_begin.
       55 ( 0.00%) 0          0                  0          0          0           55 ( 0.00%) 0          0           	    _M_buckets[_M_bucket_index(*__node->_M_next())] = __node;
        .          .          .                  .          .          .            .          .          .           
      168 ( 0.00%) 0          0                  0          0          0           56 ( 0.00%) 0          0           	  _M_buckets[__bkt] = &_M_before_begin;
        .          .          .                  .          .          .            .          .          .           	}
        .          .          .                  .          .          .            .          .          .               }
        .          .          .                  .          .          .            .          .          .           
        .          .          .                  .          .          .            .          .          .             template<typename _Key, typename _Value, typename _Alloc,
        .          .          .                  .          .          .            .          .          .           	   typename _ExtractKey, typename _Equal,
        .          .          .                  .          .          .            .          .          .           	   typename _Hash, typename _RangeHash, typename _Unused,
        .          .          .                  .          .          .            .          .          .           	   typename _RehashPolicy, typename _Traits>
        .          .          .                  .          .          .            .          .          .               void
-- line 1918 ----------------------------------------
-- line 2006 ----------------------------------------
        .          .          .                  .          .          .            .          .          .           	   typename _RehashPolicy, typename _Traits>
        .          .          .                  .          .          .            .          .          .               auto
        .          .          .                  .          .          .            .          .          .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        .          .          .                  .          .          .            .          .          .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
        .          .          .                  .          .          .            .          .          .               _M_insert_unique_node(size_type __bkt, __hash_code __code,
        .          .          .                  .          .          .            .          .          .           			  __node_ptr __node, size_type __n_elt)
        .          .          .                  .          .          .            .          .          .               -> iterator
        .          .          .                  .          .          .            .          .          .               {
      128 ( 0.00%) 0          0                 64 ( 0.00%) 0          0           64 ( 0.00%) 0          0                 const __rehash_state& __saved_state = _M_rehash_policy._M_state();
        .          .          .                  .          .          .            .          .          .                 std::pair<bool, std::size_t> __do_rehash
      384 ( 0.00%) 0          0                128 ( 0.00%) 0          0           64 ( 0.00%) 0          0           	= _M_rehash_policy._M_need_rehash(_M_bucket_count, _M_element_count,
        .          .          .                  .          .          .            .          .          .           					  __n_elt);
        .          .          .                  .          .          .            .          .          .           
      128 ( 0.00%) 0          0                  0          0          0            0          0          0                 if (__do_rehash.first)
        .          .          .                  .          .          .            .          .          .           	{
       12 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         0          0          0            4 ( 0.00%) 0          0           	  _M_rehash(__do_rehash.second, __saved_state);
        .          .          .                  .          .          .            .          .          .           	  __bkt = _M_bucket_index(__code);
        .          .          .                  .          .          .            .          .          .           	}
        .          .          .                  .          .          .            .          .          .           
        .          .          .                  .          .          .            .          .          .                 this->_M_store_code(*__node, __code);
        .          .          .                  .          .          .            .          .          .           
        .          .          .                  .          .          .            .          .          .                 // Always insert at the beginning of the bucket.
        .          .          .                  .          .          .            .          .          .                 _M_insert_bucket_begin(__bkt, __node);
       64 ( 0.00%) 0          0                 64 ( 0.00%) 0          0            0          0          0                 ++_M_element_count;
        .          .          .                  .          .          .            .          .          .                 return iterator(__node);
        .          .          .                  .          .          .            .          .          .               }
        .          .          .                  .          .          .            .          .          .           
        .          .          .                  .          .          .            .          .          .             template<typename _Key, typename _Value, typename _Alloc,
        .          .          .                  .          .          .            .          .          .           	   typename _ExtractKey, typename _Equal,
        .          .          .                  .          .          .            .          .          .           	   typename _Hash, typename _RangeHash, typename _Unused,
        .          .          .                  .          .          .            .          .          .           	   typename _RehashPolicy, typename _Traits>
        .          .          .                  .          .          .            .          .          .               auto
-- line 2037 ----------------------------------------
-- line 2313 ----------------------------------------
        .          .          .                  .          .          .            .          .          .           	   typename _Hash, typename _RangeHash, typename _Unused,
        .          .          .                  .          .          .            .          .          .           	   typename _RehashPolicy, typename _Traits>
        .          .          .                  .          .          .            .          .          .               void
        .          .          .                  .          .          .            .          .          .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        .          .          .                  .          .          .            .          .          .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
        .          .          .                  .          .          .            .          .          .               clear() noexcept
        .          .          .                  .          .          .            .          .          .               {
        .          .          .                  .          .          .            .          .          .                 this->_M_deallocate_nodes(_M_begin());
        5 ( 0.00%) 0          0                  2 ( 0.00%) 0          0            1 ( 0.00%) 0          0                 __builtin_memset(_M_buckets, 0,
        .          .          .                  .          .          .            .          .          .           		       _M_bucket_count * sizeof(__node_base_ptr));
        1 ( 0.00%) 0          0                  0          0          0            1 ( 0.00%) 0          0                 _M_element_count = 0;
        1 ( 0.00%) 0          0                  0          0          0            1 ( 0.00%) 0          0                 _M_before_begin._M_nxt = nullptr;
        .          .          .                  .          .          .            .          .          .               }
        .          .          .                  .          .          .            .          .          .           
        .          .          .                  .          .          .            .          .          .             template<typename _Key, typename _Value, typename _Alloc,
        .          .          .                  .          .          .            .          .          .           	   typename _ExtractKey, typename _Equal,
        .          .          .                  .          .          .            .          .          .           	   typename _Hash, typename _RangeHash, typename _Unused,
        .          .          .                  .          .          .            .          .          .           	   typename _RehashPolicy, typename _Traits>
        .          .          .                  .          .          .            .          .          .               void
        .          .          .                  .          .          .            .          .          .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
-- line 2332 ----------------------------------------
-- line 2347 ----------------------------------------
        .          .          .                  .          .          .            .          .          .           	_M_rehash_policy._M_reset(__saved_state);
        .          .          .                  .          .          .            .          .          .               }
        .          .          .                  .          .          .            .          .          .           
        .          .          .                  .          .          .            .          .          .             template<typename _Key, typename _Value, typename _Alloc,
        .          .          .                  .          .          .            .          .          .           	   typename _ExtractKey, typename _Equal,
        .          .          .                  .          .          .            .          .          .           	   typename _Hash, typename _RangeHash, typename _Unused,
        .          .          .                  .          .          .            .          .          .           	   typename _RehashPolicy, typename _Traits>
        .          .          .                  .          .          .            .          .          .               void
       32 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         0          0          0           16 ( 0.00%) 0          0               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        .          .          .                  .          .          .            .          .          .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
        .          .          .                  .          .          .            .          .          .               _M_rehash(size_type __bkt_count, const __rehash_state& __state)
        .          .          .                  .          .          .            .          .          .               {
        .          .          .                  .          .          .            .          .          .                 __try
        .          .          .                  .          .          .            .          .          .           	{
        .          .          .                  .          .          .            .          .          .           	  _M_rehash_aux(__bkt_count, __unique_keys{});
        .          .          .                  .          .          .            .          .          .           	}
        .          .          .                  .          .          .            .          .          .                 __catch(...)
        .          .          .                  .          .          .            .          .          .           	{
        .          .          .                  .          .          .            .          .          .           	  // A failure here means that buckets allocation failed.  We only
        .          .          .                  .          .          .            .          .          .           	  // have to restore hash policy previous state.
        .          .          .                  .          .          .            .          .          .           	  _M_rehash_policy._M_reset(__state);
        .          .          .                  .          .          .            .          .          .           	  __throw_exception_again;
        .          .          .                  .          .          .            .          .          .           	}
       24 ( 0.00%) 0          0                 20 ( 0.00%) 0          0            0          0          0               }
        .          .          .                  .          .          .            .          .          .           
        .          .          .                  .          .          .            .          .          .             // Rehash when there is no equivalent elements.
        .          .          .                  .          .          .            .          .          .             template<typename _Key, typename _Value, typename _Alloc,
        .          .          .                  .          .          .            .          .          .           	   typename _ExtractKey, typename _Equal,
        .          .          .                  .          .          .            .          .          .           	   typename _Hash, typename _RangeHash, typename _Unused,
        .          .          .                  .          .          .            .          .          .           	   typename _RehashPolicy, typename _Traits>
        .          .          .                  .          .          .            .          .          .               void
        .          .          .                  .          .          .            .          .          .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        .          .          .                  .          .          .            .          .          .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
        .          .          .                  .          .          .            .          .          .               _M_rehash_aux(size_type __bkt_count, true_type /* __uks */)
        .          .          .                  .          .          .            .          .          .               {
        .          .          .                  .          .          .            .          .          .                 __buckets_ptr __new_buckets = _M_allocate_buckets(__bkt_count);
        .          .          .                  .          .          .            .          .          .                 __node_ptr __p = _M_begin();
        4 ( 0.00%) 0          0                  0          0          0            4 ( 0.00%) 0          0                 _M_before_begin._M_nxt = nullptr;
        4 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         0          0          0            0          0          0                 std::size_t __bbegin_bkt = 0;
      213 ( 0.00%) 0          0                  0          0          0            0          0          0                 while (__p)
        .          .          .                  .          .          .            .          .          .           	{
        .          .          .                  .          .          .            .          .          .           	  __node_ptr __next = __p->_M_next();
        .          .          .                  .          .          .            .          .          .           	  std::size_t __bkt
        .          .          .                  .          .          .            .          .          .           	    = __hash_code_base::_M_bucket_index(*__p, __bkt_count);
      404 ( 0.00%) 0          0                101 ( 0.00%) 0          0            0          0          0           	  if (!__new_buckets[__bkt])
        .          .          .                  .          .          .            .          .          .           	    {
      202 ( 0.00%) 0          0                101 ( 0.00%) 0          0          101 ( 0.00%) 0          0           	      __p->_M_nxt = _M_before_begin._M_nxt;
      101 ( 0.00%) 0          0                  0          0          0          101 ( 0.00%) 0          0           	      _M_before_begin._M_nxt = __p;
      105 ( 0.00%) 0          0                  0          0          0          101 ( 0.00%) 0          0           	      __new_buckets[__bkt] = &_M_before_begin;
      202 ( 0.00%) 0          0                101 ( 0.00%) 0          0            0          0          0           	      if (__p->_M_nxt)
       98 ( 0.00%) 0          0                  0          0          0           98 ( 0.00%) 0          0           		__new_buckets[__bbegin_bkt] = __p;
      199 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         0          0          0            0          0          0           	      __bbegin_bkt = __bkt;
        .          .          .                  .          .          .            .          .          .           	    }
        .          .          .                  .          .          .            .          .          .           	  else
        .          .          .                  .          .          .            .          .          .           	    {
        .          .          .                  .          .          .            .          .          .           	      __p->_M_nxt = __new_buckets[__bkt]->_M_nxt;
        .          .          .                  .          .          .            .          .          .           	      __new_buckets[__bkt]->_M_nxt = __p;
        .          .          .                  .          .          .            .          .          .           	    }
        .          .          .                  .          .          .            .          .          .           
        .          .          .                  .          .          .            .          .          .           	  __p = __next;
        .          .          .                  .          .          .            .          .          .           	}
        .          .          .                  .          .          .            .          .          .           
        .          .          .                  .          .          .            .          .          .                 _M_deallocate_buckets();
        4 ( 0.00%) 0          0                  0          0          0            4 ( 0.00%) 0          0                 _M_bucket_count = __bkt_count;
        4 ( 0.00%) 0          0                  0          0          0            4 ( 0.00%) 0          0                 _M_buckets = __new_buckets;
        .          .          .                  .          .          .            .          .          .               }
        .          .          .                  .          .          .            .          .          .           
        .          .          .                  .          .          .            .          .          .             // Rehash when there can be equivalent elements, preserve their relative
        .          .          .                  .          .          .            .          .          .             // order.
        .          .          .                  .          .          .            .          .          .             template<typename _Key, typename _Value, typename _Alloc,
        .          .          .                  .          .          .            .          .          .           	   typename _ExtractKey, typename _Equal,
        .          .          .                  .          .          .            .          .          .           	   typename _Hash, typename _RangeHash, typename _Unused,
        .          .          .                  .          .          .            .          .          .           	   typename _RehashPolicy, typename _Traits>
-- line 2419 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/unordered_map.h
--------------------------------------------------------------------------------
Ir                 I1mr       ILmr       Dr         D1mr       DLmr       Dw                 D1mw       DLmw       

-- line 94 ----------------------------------------
        .          .          .          .          .          .                  .          .          .              *
        .          .          .          .          .          .                  .          .          .              *  Base is _Hashtable, dispatched at compile time via template
        .          .          .          .          .          .                  .          .          .              *  alias __umap_hashtable.
        .          .          .          .          .          .                  .          .          .              */
        .          .          .          .          .          .                  .          .          .             template<typename _Key, typename _Tp,
        .          .          .          .          .          .                  .          .          .           	   typename _Hash = hash<_Key>,
        .          .          .          .          .          .                  .          .          .           	   typename _Pred = equal_to<_Key>,
        .          .          .          .          .          .                  .          .          .           	   typename _Alloc = allocator<std::pair<const _Key, _Tp>>>
        2 ( 0.00%) 0          0          0          0          0                  1 ( 0.00%) 0          0               class unordered_map
        .          .          .          .          .          .                  .          .          .               {
        .          .          .          .          .          .                  .          .          .                 typedef __umap_hashtable<_Key, _Tp, _Hash, _Pred, _Alloc>  _Hashtable;
        .          .          .          .          .          .                  .          .          .                 _Hashtable _M_h;
        .          .          .          .          .          .                  .          .          .           
        .          .          .          .          .          .                  .          .          .               public:
        .          .          .          .          .          .                  .          .          .                 // typedefs:
        .          .          .          .          .          .                  .          .          .                 ///@{
        .          .          .          .          .          .                  .          .          .                 /// Public typedefs.
-- line 110 ----------------------------------------
-- line 976 ----------------------------------------
        .          .          .          .          .          .                  .          .          .                  *  Lookup requires constant time.
        .          .          .          .          .          .                  .          .          .                  */
        .          .          .          .          .          .                  .          .          .                 mapped_type&
        .          .          .          .          .          .                  .          .          .                 operator[](const key_type& __k)
        .          .          .          .          .          .                  .          .          .                 { return _M_h[__k]; }
        .          .          .          .          .          .                  .          .          .           
        .          .          .          .          .          .                  .          .          .                 mapped_type&
        .          .          .          .          .          .                  .          .          .                 operator[](key_type&& __k)
5,780,420 ( 0.17%) 2 ( 0.08%) 2 ( 0.08%) 0          0          0          2,023,267 ( 0.40%) 0          0                 { return _M_h[std::move(__k)]; }
        .          .          .          .          .          .                  .          .          .                 ///@}
        .          .          .          .          .          .                  .          .          .           
        .          .          .          .          .          .                  .          .          .                 ///@{
        .          .          .          .          .          .                  .          .          .                 /**
        .          .          .          .          .          .                  .          .          .                  *  @brief  Access to %unordered_map data.
        .          .          .          .          .          .                  .          .          .                  *  @param  __k  The key for which data should be retrieved.
        .          .          .          .          .          .                  .          .          .                  *  @return  A reference to the data whose key is equal to @a __k, if
        .          .          .          .          .          .                  .          .          .                  *           such a data is present in the %unordered_map.
-- line 992 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/juanb3ltran/Documentos/Universidad/Alto_rendimiento/Cream_drop/Main/main.cpp
--------------------------------------------------------------------------------
Ir                  I1mr       ILmr       Dr                  D1mr       DLmr       Dw                  D1mw       DLmw       

         .          .          .                   .          .          .                   .          .          .           #include "utils.hpp"
         .          .          .                   .          .          .                   .          .          .           
         .          .          .                   .          .          .                   .          .          .           
        13 ( 0.00%) 2 ( 0.08%) 2 ( 0.08%)          2 ( 0.00%) 1 ( 0.01%) 0                   7 ( 0.00%) 0          0           int main(int argc, char *argv[]) {
         .          .          .                   .          .          .                   .          .          .               //Declara variables
         .          .          .                   .          .          .                   .          .          .               int t_final, N_particles, divisions, seed;    
         .          .          .                   .          .          .                   .          .          .               double size, x_min, x_max, y_min, y_max;
         .          .          .                   .          .          .                   .          .          .           
         .          .          .                   .          .          .                   .          .          .               //lee el input asumiendo que cada valor tiene un comentario (que debe ser ignorado)
        10 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)          0          0          0                   2 ( 0.00%) 1 ( 0.04%) 0               std::cin >> N_particles; std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
         4 ( 0.00%) 0          0                   0          0          0                   1 ( 0.00%) 0          0               std::cin >> size; std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
         7 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)          0          0          0                   2 ( 0.00%) 0          0               std::cin >> t_final; std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
         7 ( 0.00%) 0          0                   0          0          0                   2 ( 0.00%) 0          0               std::cin >> divisions; std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
         7 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)          0          0          0                   2 ( 0.00%) 0          0               std::cin >> seed; std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
         .          .          .                   .          .          .                   .          .          .           
         .          .          .                   .          .          .                   .          .          .               // limites del contenedor
         4 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)          2 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)          2 ( 0.00%) 0          0               x_min=-size;
         .          .          .                   .          .          .                   .          .          .               x_max=size;
         .          .          .                   .          .          .                   .          .          .               y_min=-size;
         .          .          .                   .          .          .                   .          .          .               y_max=size;
         .          .          .                   .          .          .                   .          .          .           
         .          .          .                   .          .          .                   .          .          .               //Crea el vector de particulas y el generador aleatorio
         .          .          .                   .          .          .                   .          .          .               std::vector<Particle> balls;
         .          .          .                   .          .          .                   .          .          .               std::mt19937 gen(seed);
         .          .          .                   .          .          .                   .          .          .           
         .          .          .                   .          .          .                   .          .          .               // Inicializa n objetos de la clase Particle y los añade al vector
         5 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)          2 ( 0.00%) 0          0                   1 ( 0.00%) 0          0               inicializar(balls, N_particles, size);
         .          .          .                   .          .          .                   .          .          .               //grid entropy
         .          .          .                   .          .          .                   .          .          .               std::unordered_map<int,int> grid_counts;
     2,005 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)        400 ( 0.00%) 0          0                 400 ( 0.00%) 0          0               for (auto ball : balls){
     5,600 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)      1,600 ( 0.00%) 0          0               1,600 ( 0.00%) 0          0                   counts(grid_counts, ball.getX(), ball.getY(), x_min, x_max, y_min, y_max, divisions);
         .          .          .                   .          .          .                   .          .          .               }
         4 ( 0.00%) 0          0                   1 ( 0.00%) 0          0                   2 ( 0.00%) 0          0               double entropy = compute_entropy(grid_counts, N_particles);
         .          .          .                   .          .          .                   .          .          .              
         .          .          .                   .          .          .                   .          .          .               int coin;
18,000,005 ( 0.52%) 0          0           6,000,001 ( 0.72%) 0          0                   0          0          0               for (int i = 0; i < t_final; i++)
         .          .          .                   .          .          .                   .          .          .               {
         .          .          .                   .          .          .                   .          .          .                   
30,000,000 ( 0.86%) 1 ( 0.04%) 1 ( 0.04%)  6,000,000 ( 0.72%) 0          0           6,000,000 ( 1.19%) 0          0                   coin = getRandomInt(N_particles-1, gen); //Selecciona que particula se movera
         .          .          .                   .          .          .                   .          .          .                   // %%%%%%%%%%%%% Posicion antigua %%%%%%%%%%%%%
18,000,000 ( 0.52%) 0          0                   0          0          0           6,000,000 ( 1.19%) 0          0                   double old_x = balls[coin].getX();
12,000,000 ( 0.35%) 0          0                   0          0          0           6,000,000 ( 1.19%) 0          0                   double old_y = balls[coin].getY();
48,000,000 ( 1.38%) 1 ( 0.04%) 1 ( 0.04%) 18,000,000 ( 2.17%) 0          0           6,000,000 ( 1.19%) 0          0                   balls[coin].moveRandom(1, x_min, x_max, y_min, y_max, gen);        
         .          .          .                   .          .          .                   .          .          .                   
         .          .          .                   .          .          .                   .          .          .                   // %%%%%%%%%%%%% Posicion actual %%%%%%%%%%%%%
12,000,000 ( 0.35%) 1 ( 0.04%) 1 ( 0.04%)          0          0          0          12,000,000 ( 2.37%) 0          0                   double new_x = balls[coin].getX();
12,000,000 ( 0.35%) 0          0                   0          0          0           6,000,000 ( 1.19%) 0          0                   double new_y = balls[coin].getY();
         .          .          .                   .          .          .                   .          .          .                   
         .          .          .                   .          .          .                   .          .          .                   // %%%%%%%%%%%%% Calcula el cambio en la entropia (2 casos) %%%%%%%%%%%%%
66,000,000 ( 1.90%) 1 ( 0.04%) 1 ( 0.04%) 30,000,000 ( 3.62%) 0          0           6,000,000 ( 1.19%) 0          0                   double ds = delta_entropy(grid_counts, new_x, new_y, x_min, x_max, y_min, y_max, divisions, old_x, old_y, N_particles);
12,000,000 ( 0.35%) 0          0           6,000,000 ( 0.72%) 0          0           6,000,000 ( 1.19%) 0          0                   entropy += ds;
         .          .          .                   .          .          .                   .          .          .                
         .          .          .                   .          .          .                   .          .          .                   
         .          .          .                   .          .          .                   .          .          .               }
         .          .          .                   .          .          .                   .          .          .               std::cout<<"Entropía final: "<<entropy;
         .          .          .                   .          .          .                   .          .          .               return 0;
        15 ( 0.00%) 2 ( 0.08%) 1 ( 0.04%)         10 ( 0.00%) 1 ( 0.01%) 0                   1 ( 0.00%) 0          0           }
--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/uniform_int_dist.h
--------------------------------------------------------------------------------
Ir                   I1mr       ILmr       Dr                  D1mr       DLmr       Dw                  D1mw       DLmw       

-- line 185 ----------------------------------------
          .          .          .                   .          .          .                   .          .          .                 { return this->b(); }
          .          .          .                   .          .          .                   .          .          .           
          .          .          .                   .          .          .                   .          .          .                 /**
          .          .          .                   .          .          .                   .          .          .                  * @brief Generating functions.
          .          .          .                   .          .          .                   .          .          .                  */
          .          .          .                   .          .          .                   .          .          .                 template<typename _UniformRandomBitGenerator>
          .          .          .                   .          .          .                   .          .          .           	result_type
          .          .          .                   .          .          .                   .          .          .           	operator()(_UniformRandomBitGenerator& __urng)
 54,269,811 ( 1.56%) 0          0                   0          0          0          12,059,958 ( 2.39%) 0          0                   { return this->operator()(__urng, _M_param); }
          .          .          .                   .          .          .                   .          .          .           
          .          .          .                   .          .          .                   .          .          .                 template<typename _UniformRandomBitGenerator>
          .          .          .                   .          .          .                   .          .          .           	result_type
          .          .          .                   .          .          .                   .          .          .           	operator()(_UniformRandomBitGenerator& __urng,
          .          .          .                   .          .          .                   .          .          .           		   const param_type& __p);
          .          .          .                   .          .          .                   .          .          .           
          .          .          .                   .          .          .                   .          .          .                 template<typename _ForwardIterator,
          .          .          .                   .          .          .                   .          .          .           	       typename _UniformRandomBitGenerator>
-- line 201 ----------------------------------------
-- line 250 ----------------------------------------
          .          .          .                   .          .          .                   .          .          .           	  static_assert(!_Up_traits::__is_signed, "U must be unsigned");
          .          .          .                   .          .          .                   .          .          .           	  static_assert(!_Wp_traits::__is_signed, "W must be unsigned");
          .          .          .                   .          .          .                   .          .          .           	  static_assert(_Wp_traits::__digits == (2 * _Up_traits::__digits),
          .          .          .                   .          .          .                   .          .          .           			"W must be twice as wide as U");
          .          .          .                   .          .          .                   .          .          .           
          .          .          .                   .          .          .                   .          .          .           	  // reference: Fast Random Integer Generation in an Interval
          .          .          .                   .          .          .                   .          .          .           	  // ACM Transactions on Modeling and Computer Simulation 29 (1), 2019
          .          .          .                   .          .          .                   .          .          .           	  // https://arxiv.org/abs/1805.10941
 18,059,958 ( 0.52%) 0          0                   0          0          0                   0          0          0           	  _Wp __product = _Wp(__g()) * _Wp(__range);
          .          .          .                   .          .          .                   .          .          .           	  _Up __low = _Up(__product);
 36,119,916 ( 1.04%) 0          0                   0          0          0                   0          0          0           	  if (__low < __range)
          .          .          .                   .          .          .                   .          .          .           	    {
          .          .          .                   .          .          .                   .          .          .           	      _Up __threshold = -__range % __range;
          .          .          .                   .          .          .                   .          .          .           	      while (__low < __threshold)
          .          .          .                   .          .          .                   .          .          .           		{
          .          .          .                   .          .          .                   .          .          .           		  __product = _Wp(__g()) * _Wp(__range);
          .          .          .                   .          .          .                   .          .          .           		  __low = _Up(__product);
          .          .          .                   .          .          .                   .          .          .           		}
          .          .          .                   .          .          .                   .          .          .           	    }
 30,119,916 ( 0.87%) 1 ( 0.04%) 1 ( 0.04%)          0          0          0                   0          0          0           	  return __product >> _Up_traits::__digits;
          .          .          .                   .          .          .                   .          .          .           	}
          .          .          .                   .          .          .                   .          .          .               };
          .          .          .                   .          .          .                   .          .          .           
          .          .          .                   .          .          .                   .          .          .             template<typename _IntType>
          .          .          .                   .          .          .                   .          .          .               template<typename _UniformRandomBitGenerator>
          .          .          .                   .          .          .                   .          .          .                 typename uniform_int_distribution<_IntType>::result_type
120,599,580 ( 3.47%) 1 ( 0.04%) 1 ( 0.04%)          0          0          0          72,359,748 (14.31%) 0          0                 uniform_int_distribution<_IntType>::
          .          .          .                   .          .          .                   .          .          .                 operator()(_UniformRandomBitGenerator& __urng,
          .          .          .                   .          .          .                   .          .          .           		 const param_type& __param)
          .          .          .                   .          .          .                   .          .          .                 {
          .          .          .                   .          .          .                   .          .          .           	typedef typename _UniformRandomBitGenerator::result_type _Gresult_type;
          .          .          .                   .          .          .                   .          .          .           	typedef typename make_unsigned<result_type>::type __utype;
          .          .          .                   .          .          .                   .          .          .           	typedef typename common_type<_Gresult_type, __utype>::type __uctype;
          .          .          .                   .          .          .                   .          .          .           
          .          .          .                   .          .          .                   .          .          .           	constexpr __uctype __urngmin = _UniformRandomBitGenerator::min();
          .          .          .                   .          .          .                   .          .          .           	constexpr __uctype __urngmax = _UniformRandomBitGenerator::max();
          .          .          .                   .          .          .                   .          .          .           	static_assert( __urngmin < __urngmax,
          .          .          .                   .          .          .                   .          .          .           	    "Uniform random bit generator must define min() < max()");
          .          .          .                   .          .          .                   .          .          .           	constexpr __uctype __urngrange = __urngmax - __urngmin;
          .          .          .                   .          .          .                   .          .          .           
 12,059,958 ( 0.35%) 0          0                   0          0          0                   0          0          0           	const __uctype __urange
 12,059,958 ( 0.35%) 0          0                   0          0          0                   0          0          0           	  = __uctype(__param.b()) - __uctype(__param.a());
          .          .          .                   .          .          .                   .          .          .           
          .          .          .                   .          .          .                   .          .          .           	__uctype __ret;
 54,179,874 ( 1.56%) 0          0                   0          0          0                   0          0          0           	if (__urngrange > __urange)
          .          .          .                   .          .          .                   .          .          .           	  {
          .          .          .                   .          .          .                   .          .          .           	    // downscaling
          .          .          .                   .          .          .                   .          .          .           
 18,059,958 ( 0.52%) 0          0                   0          0          0                   0          0          0           	    const __uctype __uerange = __urange + 1; // __urange can be zero
          .          .          .                   .          .          .                   .          .          .           
          .          .          .                   .          .          .                   .          .          .           #if defined __UINT64_TYPE__ && defined __UINT32_TYPE__
          .          .          .                   .          .          .                   .          .          .           #if __SIZEOF_INT128__
          .          .          .                   .          .          .                   .          .          .           	    if _GLIBCXX17_CONSTEXPR (__urngrange == __UINT64_MAX__)
          .          .          .                   .          .          .                   .          .          .           	      {
          .          .          .                   .          .          .                   .          .          .           		// __urng produces values that use exactly 64-bits,
          .          .          .                   .          .          .                   .          .          .           		// so use 128-bit integers to downscale to desired range.
          .          .          .                   .          .          .                   .          .          .           		__UINT64_TYPE__ __u64erange = __uerange;
-- line 306 ----------------------------------------
-- line 307 ----------------------------------------
          .          .          .                   .          .          .                   .          .          .           		__ret = _S_nd<unsigned __int128>(__urng, __u64erange);
          .          .          .                   .          .          .                   .          .          .           	      }
          .          .          .                   .          .          .                   .          .          .           	    else
          .          .          .                   .          .          .                   .          .          .           #endif
          .          .          .                   .          .          .                   .          .          .           	    if _GLIBCXX17_CONSTEXPR (__urngrange == __UINT32_MAX__)
          .          .          .                   .          .          .                   .          .          .           	      {
          .          .          .                   .          .          .                   .          .          .           		// __urng produces values that use exactly 32-bits,
          .          .          .                   .          .          .                   .          .          .           		// so use 64-bit integers to downscale to desired range.
 18,059,958 ( 0.52%) 0          0                   0          0          0                   0          0          0           		__UINT32_TYPE__ __u32erange = __uerange;
          .          .          .                   .          .          .                   .          .          .           		__ret = _S_nd<__UINT64_TYPE__>(__urng, __u32erange);
          .          .          .                   .          .          .                   .          .          .           	      }
          .          .          .                   .          .          .                   .          .          .           	    else
          .          .          .                   .          .          .                   .          .          .           #endif
          .          .          .                   .          .          .                   .          .          .           	      {
          .          .          .                   .          .          .                   .          .          .           		// fallback case (2 divisions)
          .          .          .                   .          .          .                   .          .          .           		const __uctype __scaling = __urngrange / __uerange;
          .          .          .                   .          .          .                   .          .          .           		const __uctype __past = __uerange * __scaling;
-- line 323 ----------------------------------------
-- line 352 ----------------------------------------
          .          .          .                   .          .          .                   .          .          .           			 (__urng, param_type(0, __urange / __uerngrange)));
          .          .          .                   .          .          .                   .          .          .           		__ret = __tmp + (__uctype(__urng()) - __urngmin);
          .          .          .                   .          .          .                   .          .          .           	      }
          .          .          .                   .          .          .                   .          .          .           	    while (__ret > __urange || __ret < __tmp);
          .          .          .                   .          .          .                   .          .          .           	  }
          .          .          .                   .          .          .                   .          .          .           	else
          .          .          .                   .          .          .                   .          .          .           	  __ret = __uctype(__urng()) - __urngmin;
          .          .          .                   .          .          .                   .          .          .           
 18,059,958 ( 0.52%) 0          0                   0          0          0                   0          0          0           	return __ret + __param.a();
 96,479,664 ( 2.78%) 0          0          84,419,706 (10.17%) 0          0                   0          0          0                 }
          .          .          .                   .          .          .                   .          .          .           
          .          .          .                   .          .          .                   .          .          .           
          .          .          .                   .          .          .                   .          .          .             template<typename _IntType>
          .          .          .                   .          .          .                   .          .          .               template<typename _ForwardIterator,
          .          .          .                   .          .          .                   .          .          .           	     typename _UniformRandomBitGenerator>
          .          .          .                   .          .          .                   .          .          .                 void
          .          .          .                   .          .          .                   .          .          .                 uniform_int_distribution<_IntType>::
          .          .          .                   .          .          .                   .          .          .                 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
-- line 369 ----------------------------------------

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  ./malloc/./malloc/arena.c
  ./malloc/./malloc/malloc.c
  ./math/../sysdeps/ieee754/dbl-64/e_log.c
  ./math/./w_log_template.c

--------------------------------------------------------------------------------
Ir                     I1mr        ILmr        Dr                   D1mr        DLmr       Dw                   D1mw         DLmw        
--------------------------------------------------------------------------------
2,456,847,934 (70.73%) 75 ( 2.82%) 74 ( 2.99%) 536,426,289 (64.65%) 20 ( 0.14%) 1 ( 0.01%) 367,379,702 (72.66%) 159 ( 5.59%) 99 ( 5.37%)  events annotated

